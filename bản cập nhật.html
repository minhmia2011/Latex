<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>C√¥ng c·ª• h·ªó tr·ª£ v·∫Ω bi·ªÉu ƒë·ªì v√† v·∫Ω h√¨nh LaTeX (Pro Version)</title>
    <style type="text/css">@font-face {font-family:Inter;font-style:normal;font-weight:300;src:url(https://fonts.gstatic.com/s/inter/v13/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuOKfAZ9hjp-Ek-_EeA.woff2) format('woff2');} @font-face {font-family:Inter;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/inter/v13/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuLyfAZ9hjp-Ek-_EeA.woff2) format('woff2');} @font-face {font-family:Inter;font-style:normal;font-weight:500;src:url(https://fonts.gstatic.com/s/inter/v13/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuI6fAZ9hjp-Ek-_EeA.woff2) format('woff2');} @font-face {font-family:Inter;font-style:normal;font-weight:600;src:url(https://fonts.gstatic.com/s/inter/v13/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuGKYAZ9hjp-Ek-_EeA.woff2) format('woff2');} @font-face {font-family:Inter;font-style:normal;font-weight:700;src:url(https://fonts.gstatic.com/s/inter/v13/UcCO3FwrK3iLTeHuS_fvQtMwCp50KnMw2boKoduKmMEVuFuYAZ9hjp-Ek-_EeA.woff2) format('woff2');}</style>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <style>
        :root {
            /* --- Educational Theme Palette (Light & Clean) --- */
            --bg-sidebar: #ffffff;      
            --bg-body: #f3f4f6;         
            --bg-card: #ffffff;
            --text-main: #1f2937;       
            --text-heading: #111827;
            --primary: #2563eb;         
            --primary-hover: #1d4ed8;
            --accent: #4f46e5;
            --border: #d1d5db;          
            --input-bg: #ffffff;
            --sidebar-text: #4b5563;
            --sidebar-active: #2563eb;
            --sidebar-active-bg: #eff6ff;
            --sidebar-border: #e5e7eb;
        }
        #geo-canvas {
        touch-action: none;
    }

        body { 
            margin: 0; padding: 0; height: 100vh; display: flex; 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            background-color: var(--bg-body); 
            color: var(--text-main); font-size: 14px; 
            overflow: hidden; 
        }
        
        /* --- SIDEBAR STYLE --- */
        #sidebar { 
            width: 240px; background: var(--bg-sidebar); 
            display: flex; flex-direction: column; flex-shrink: 0; z-index: 100;
            border-right: 1px solid var(--sidebar-border);
            box-shadow: 2px 0 5px rgba(0,0,0,0.02);
            transition: all 0.3s;
        }
        .brand-box { 
            padding: 18px 20px; font-weight: 700; color: var(--primary); font-size: 1.2rem; 
            display: flex; align-items: center; gap: 10px; 
            border-bottom: 1px solid var(--sidebar-border); letter-spacing: 0.5px;
        }
        .brand-box i { color: var(--primary); font-size: 1.4rem; }
        .menu-list { flex: 1; padding: 15px 10px; overflow-y: auto; }
        .menu-item { 
            display: flex; align-items: center; width: 100%; text-align: left; 
            padding: 12px 15px; margin-bottom: 5px; border: none; background: transparent; 
            border-radius: 8px; color: var(--sidebar-text); font-weight: 500; font-size: 14px; 
            cursor: pointer; transition: all 0.2s ease; 
        }
        .menu-item:hover { background-color: #f9fafb; color: var(--primary); }
        .menu-item.active { 
            background-color: var(--sidebar-active-bg); 
            color: var(--sidebar-active); 
            font-weight: 600;
        }
        .menu-item i { width: 24px; text-align: center; margin-right: 10px; font-size: 16px; }

        /* --- MAIN CONTENT --- */
        #main-wrapper { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; }
        
        .top-bar { 
            height: 56px; background: var(--bg-card); border-bottom: 1px solid var(--border); 
            display: flex; align-items: center; padding: 0 20px; justify-content: space-between; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.02);
        }
        .app-title { font-weight: 700; color: var(--text-heading); font-size: 16px; letter-spacing: 0.5px; }

        /* --- COMPONENTS STYLE --- */
        .card { 
            border: 1px solid var(--border); border-radius: 8px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.03); margin-bottom: 15px; 
            background: #fff; overflow: hidden;
        }
        .card-header { 
            background: #f8fafc; border-bottom: 1px solid var(--border); 
            font-weight: 600; font-size: 13px; color: var(--text-heading);
            padding: 12px 15px; text-transform: uppercase; letter-spacing: 0.5px;
            display: flex; align-items: center; gap: 8px;
        }
        .card-header i { color: var(--primary); }
        .card-body.compact-body { padding: 15px; }

        .input-group-sm .input-group-text { 
            background-color: #f9fafb; border: 1px solid var(--border); 
            border-right: none; color: var(--text-main); font-weight: 500; 
            font-size: 13px; min-width: 70px; justify-content: center;
            border-radius: 6px 0 0 6px;
        }
        .form-control, .form-select { 
            background-color: #fff; border: 1px solid var(--border); 
            font-size: 13px; color: var(--text-main); padding: 6px 10px;
            border-radius: 6px; transition: all 0.2s;
        }
        .input-group-sm > .form-control { border-radius: 0 6px 6px 0; }
        .form-control:focus, .form-select:focus { 
            border-color: var(--primary); box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15); 
            z-index: 2; outline: none;
        }
        
        .table { margin-bottom: 0; }
        .table th { 
            background-color: #f1f5f9; color: var(--text-heading); 
            font-weight: 600; font-size: 12px; text-transform: uppercase; border-bottom: 2px solid var(--border);
            padding: 10px 8px;
        }
        .table td { padding: 8px; vertical-align: middle; border-bottom: 1px solid var(--border); }
        
        .table input.form-control { 
            border: 1px solid #ced4da !important;
            background: #fff !important;
            padding: 4px 8px; 
            height: 30px; 
            border-radius: 4px;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
        }
        .table input.form-control:focus { 
            border-color: var(--primary) !important; 
            background: #fff !important; 
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.2) !important;
        }

        .btn { font-weight: 500; border-radius: 6px; transition: all 0.2s; }
        .btn-primary { background-color: var(--primary); border-color: var(--primary); }
        .btn-primary:hover { background-color: var(--primary-hover); border-color: var(--primary-hover); }
        .btn-sm { font-size: 13px; padding: 5px 12px; height: 32px; display: inline-flex; align-items: center; gap: 6px; justify-content: center; }
        
        .nav-tabs { border-bottom: 1px solid var(--border); gap: 5px; padding: 0 15px; background: #fff; }
        .nav-link { 
            border: none; border-bottom: 3px solid transparent; color: var(--sidebar-text); 
            font-weight: 500; font-size: 13px; padding: 12px 15px; border-radius: 0; 
        }
        .nav-link:hover { color: var(--primary); background: rgba(37,99,235,0.05); }
        .nav-link.active { color: var(--primary); border-bottom-color: var(--primary); background: transparent; font-weight: 600; }

        .app-view { display: none; height: calc(100vh - 56px); overflow: hidden; width: 100%; }
        .app-view.active { display: block; }
        #chart-app { padding: 20px; overflow-y: auto; background: var(--bg-body); }
        
        textarea.form-control { 
            background: #1e293b; color: #f8fafc; font-family: 'Consolas', 'Monaco', monospace; 
            font-size: 13px; border: 1px solid var(--border); line-height: 1.6; border-radius: 6px;
        }
        
        /* --- GEOMETRY UI --- */
        #geo-app { display: none; flex-direction: row; height: 100%; width: 100%; }
        #geo-app.active { display: flex; }
        
        #geo-toolbar { 
            width: 250px; background: #fff; border-right: 1px solid var(--border); 
            padding: 0; overflow-y: auto; display: flex; flex-direction: column; flex-shrink: 0;
        }
        
        .geo-tool-group { padding: 15px; border-bottom: 1px solid var(--border); }
        .geo-tool-group h4 { 
            font-size: 12px; color: var(--primary); margin: 0 0 10px; 
            font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; display: flex; align-items: center; gap: 5px;
        }
        .tool-grid { display: grid; grid-template-columns: 1fr; gap: 5px; }
        #geo-toolbar button { 
            width: 100%; padding: 8px 12px; border-radius: 6px; border: 1px solid transparent; 
            background: transparent; text-align: left; font-size: 13px; color: var(--text-main); 
            display: flex; align-items: center; gap: 10px; transition: 0.1s;
        }
        #geo-toolbar button:hover { background: #f3f4f6; color: var(--primary); border-color: #e5e7eb; }
        #geo-toolbar button.active { background: #eff6ff; color: var(--primary); border-color: var(--primary); font-weight: 600; box-shadow: 0 1px 2px rgba(37,99,235,0.1); }
        #geo-toolbar button i { width: 18px; text-align: center; opacity: 0.8; }
        
        #geo-main-area { flex: 1; display: flex; flex-direction: column; padding: 15px; background: #e5e7eb; transition: padding 0.3s; overflow: hidden; }
        
        #geo-controls { 
            background: #fff; padding: 10px 15px; border-radius: 8px; border: 1px solid var(--border);
            box-shadow: 0 2px 4px rgba(0,0,0,0.03); display: flex; gap: 15px; margin-bottom: 10px; 
            align-items: center; flex-wrap: wrap; font-size: 13px; flex-shrink: 0;
        }
        .ctrl-group { display: flex; align-items: center; gap: 8px; padding-right: 15px; border-right: 1px solid var(--border); }
        
        #geo-canvas-container { 
            flex: 1; background: #fff; border-radius: 8px; border: 1px solid var(--border); 
            box-shadow: 0 4px 6px rgba(0,0,0,0.05); position: relative; overflow: hidden; 
            touch-action: none; 
            cursor: crosshair;
        }
        
        #geo-code-panel { 
            width: 300px; background: #fff; display: flex; flex-direction: column; 
            border-left: 1px solid var(--border); z-index: 50; flex-shrink: 0;
        }
        #geo-code-header { padding: 12px 15px; background: #f8fafc; color: var(--text-heading); font-weight: 700; font-size: 13px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; }
        #geo-code { padding: 15px; background: #1e293b; border: none; color: #e2e8f0; font-size: 13px; flex: 1; resize: none; border-radius: 0; }
        #geo-code-footer { padding: 8px; font-size: 11px; text-align: center; color: #64748b; background: #f8fafc; border-top: 1px solid var(--border); }
        
        /* Modal & Status */
        .geo-status { 
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); 
            background: rgba(30, 41, 59, 0.9); backdrop-filter: blur(4px);
            color: #fff; padding: 10px 25px; border-radius: 30px; display: none; 
            font-size: 13px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); z-index: 2000;
        }
        #geo-modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); backdrop-filter: blur(2px); justify-content: center; align-items: center; z-index: 3000; }
        .geo-modal-box { background: #fff; padding: 25px; border-radius: 12px; width: 320px; box-shadow: 0 20px 40px rgba(0,0,0,0.2); border: 1px solid var(--border); }

        /* --- FULLSCREEN EXPAND MODE --- */
        body.fullscreen-mode #sidebar { display: none !important; }
        body.fullscreen-mode .top-bar { display: none !important; }
        body.fullscreen-mode #geo-code-panel { display: none !important; }
        body.fullscreen-mode #geo-main-area { padding: 0; background: #fff; }
        body.fullscreen-mode #geo-controls { 
            border-radius: 0; border-left: none; border-right: none; border-top: none; 
            margin-bottom: 0; z-index: 10;
        }
        body.fullscreen-mode #geo-canvas-container { 
            border-radius: 0; border: none; 
        }
        
        /* --- RESPONSIVE MOBILE FIX --- */
        @media (max-width: 768px) {
            #sidebar { display: none; }
            #geo-toolbar { width: 60px; }
            .geo-tool-group h4 span { display: none; } 
            #geo-toolbar button { padding: 10px; justify-content: center; }
            #geo-toolbar button span { display: none; } 
            #geo-toolbar button i { margin: 0; font-size: 18px; }
            #geo-code-panel { display: none; } 
            .ctrl-group span { display: none; }
        }
    </style>
</head>
<!-- ================== H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG ================== -->
<div class="modal fade" id="guideModal" tabindex="-1">
  <div class="modal-dialog modal-lg modal-dialog-centered modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title text-primary fw-bold">
          <i class="fas fa-book me-2"></i>H∆Ø·ªöNG D·∫™N S·ª¨ D·ª§NG
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body" style="font-size:14px; line-height:1.7">

        <h6 class="fw-bold text-primary">I. Bi·ªÉu ƒë·ªì LaTeX</h6>
        <ul>
          <li>Ch·ªçn lo·∫°i bi·ªÉu ƒë·ªì: Tr√≤n, C·ªôt, C·ªôt k√©p, ƒê∆∞·ªùng, Tranh.</li>
          <li>Nh·∫≠p d·ªØ li·ªáu ‚Üí b·∫•m <b>T·∫°o Code</b>.</li>
          <li>Sao ch√©p m√£ LaTeX v√† d√°n v√†o Overleaf ho·∫∑c TeX Editor.</li>
        </ul>

        <h6 class="fw-bold text-primary mt-3">II. V·∫Ω h√¨nh tkz-euclide</h6>
        <ul>
          <li>Ch·ªçn c√¥ng c·ª• b√™n tr√°i (ƒëi·ªÉm, ƒëo·∫°n, ƒë∆∞·ªùng, ƒë∆∞·ªùng tr√≤n‚Ä¶).</li>
          <li>Click tr√™n v√πng v·∫Ω ƒë·ªÉ t·∫°o h√¨nh.</li>
          <li>M√£ tkz-euclide t·ª± ƒë·ªông sinh ·ªü khung b√™n ph·∫£i.</li>
          <li>B·∫•m <b>Copy Code</b> ƒë·ªÉ s·ª≠ d·ª•ng.</li>
        </ul>

        <h6 class="fw-bold text-primary mt-3">III. Ph√≠m t·∫Øt</h6>
        <ul>
          <li><b>Ctrl + Z</b>: Ho√†n t√°c</li>
          <li><b>Ctrl + Y</b>: L√†m l·∫°i</li>
          <li><b>Chu·ªôt</b>: V·∫Ω / Di chuy·ªÉn ƒëi·ªÉm</li>
        </ul>

        <h6 class="fw-bold text-primary mt-3">IV. L∆∞u √Ω</h6>
        <ul>
          <li>C·∫ßn g√≥i <code>tikz</code>, <code>tkz-euclide</code>, <code>patterns</code>.</li>
          <li>D√πng t·ªët nh·∫•t tr√™n m√°y t√≠nh.</li>
        </ul>

      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary btn-sm" data-bs-dismiss="modal">ƒê√≥ng</button>
      </div>
    </div>
  </div>
</div>

<body>

<div id="sidebar">
    <div class="brand-box">
        <i class="fas fa-shapes"></i> C√¥ng c·ª• LaTeX
    </div>
    <div class="menu-list">
        <button class="menu-item active" onclick="switchApp('chart')" id="btn-chart">
            <i class="fas fa-chart-pie"></i> Bi·ªÉu ƒë·ªì
        </button>
        <button class="menu-item" onclick="switchApp('geo')" id="btn-geo">
            <i class="fas fa-drafting-compass"></i> V·∫Ω h√¨nh
        </button>
        <button class="menu-item" onclick="openGuide()" id="btn-guide">
    <i class="fas fa-question-circle"></i> H∆∞·ªõng d·∫´n
</button>

    </div>
    <div class="p-3 border-top text-center text-muted" style="font-size:11px">
        S·∫¢N PH·∫®M C·ª¶A TO√ÅN.VN N·ªòI B√ÄI
    </div>
</div>

<div id="main-wrapper">
    <div class="top-bar">
        <div class="app-title" id="page-title">Bi·ªÉu ƒë·ªì LaTeX</div>
        <div id="geo-header-actions" style="display:none; gap: 8px;">
            <button class="btn btn-sm btn-outline-secondary border" id="geo-undo" disabled title="Ho√†n t√°c (Ctrl+Z)"><i class="fas fa-undo"></i></button>
            <button class="btn btn-sm btn-outline-secondary border" id="geo-redo" disabled title="L√†m l·∫°i (Ctrl+Y)"><i class="fas fa-redo"></i></button>
            <div style="width: 1px; height: 20px; background: var(--border); margin: 0 5px;"></div>
            <button class="btn btn-sm btn-success" id="geo-copy"><i class="fas fa-copy"></i> Copy Code</button>
            <button class="btn btn-sm btn-primary" id="geo-export"><i class="fas fa-download"></i> PNG</button>
        </div>
    </div>

    <div id="chart-app" class="app-view active">
        <ul class="nav nav-tabs mb-4" id="chartTabs" role="tablist">
            <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#pie"><i class="fas fa-chart-pie me-2"></i>Tr√≤n</button></li>
            <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#bar"><i class="fas fa-chart-bar me-2"></i>C·ªôt</button></li>
            <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#doublebar"><i class="fas fa-chart-bar me-2"></i>C·ªôt k√©p</button></li>
            <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#line"><i class="fas fa-chart-line me-2"></i>ƒê∆∞·ªùng</button></li>
            <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#pictogram"><i class="fas fa-icons me-2"></i>Tranh</button></li>
        </ul>

        <div class="tab-content">
            <div class="tab-pane fade show active" id="pie">
                <div class="row h-100 g-3">
                    <div class="col-md-5 d-flex flex-column">
                        <div class="card">
                            <div class="card-header"><i class="fas fa-cog"></i> C√†i ƒë·∫∑t</div>
                            <div class="card-body compact-body">
                                <div class="input-group input-group-sm">
                                    <span class="input-group-text">Ti√™u ƒë·ªÅ</span>
                                    <input type="text" class="form-control" id="pie-title" placeholder="V√≠ d·ª•: T·ªâ l·ªá h·ªçc sinh...">
                                </div>
                            </div>
                        </div>
                        <div class="card flex-grow-1">
                            <div class="card-header"><i class="fas fa-database"></i> D·ªØ li·ªáu</div>
                            <div class="card-body compact-body d-flex flex-column">
                                <div style="flex:1; overflow-y:auto; margin-bottom:10px">
                                    <table class="table" id="pie-table">
                                        <thead><tr><th>N·ªôi dung</th><th width="80">%</th><th>Pattern</th><th width="30"></th></tr></thead>
                                        <tbody></tbody>
                                    </table>
                                </div>
                                <div class="d-flex justify-content-between align-items-center pt-2 border-top">
                                    <span id="pie-sum" class="badge bg-primary bg-opacity-10 text-primary fs-6">T·ªïng: 0%</span>
                                    <button class="btn btn-sm btn-success" onclick="addRow('pie')"><i class="fas fa-plus"></i> Th√™m d√≤ng</button>
                                </div>
                            </div>
                        </div>
                        <div class="d-flex gap-2">
                            <button class="btn btn-primary flex-grow-1" onclick="generatePie()"><i class="fas fa-magic"></i> T·∫°o Code</button>
                            <button class="btn btn-outline-secondary" onclick="copyCode('pie-output')">Copy</button>
                        </div>
                    </div>
                    <div class="col-md-7">
                        <textarea class="form-control h-100" id="pie-output" placeholder="M√£ LaTeX s·∫Ω hi·ªÉn th·ªã t·∫°i ƒë√¢y..."></textarea>
                    </div>
                </div>
            </div>

            <div class="tab-pane fade" id="bar">
                <div class="row h-100 g-3">
                    <div class="col-md-5 d-flex flex-column">
                        <div class="card">
                            <div class="card-header"><i class="fas fa-cog"></i> C√†i ƒë·∫∑t</div>
                            <div class="card-body compact-body">
                                <div class="input-group input-group-sm mb-2">
                                    <span class="input-group-text">Ti√™u ƒë·ªÅ</span>
                                    <input type="text" class="form-control" id="bar-title">
                                </div>
                                <div class="row g-2 mb-2">
                                    <div class="col-4"><div class="input-group input-group-sm"><span class="input-group-text">Ox</span><input type="text" class="form-control" id="bar-xlabel"></div></div>
                                    <div class="col-4"><div class="input-group input-group-sm"><span class="input-group-text">Oy</span><input type="text" class="form-control" id="bar-ylabel"></div></div>
                                    <div class="col-4"><div class="input-group input-group-sm"><span class="input-group-text">H·ªá s·ªë</span><input type="text" class="form-control" id="bar-oyfactor" value="10"></div></div>
                                </div>
                                <div class="input-group input-group-sm">
                                    <span class="input-group-text">M√†u</span>
                                    <input type="text" class="form-control" id="bar-color" value="blue!60">
                                </div>
                            </div>
                        </div>
                        <div class="card flex-grow-1">
                            <div class="card-header"><i class="fas fa-database"></i> D·ªØ li·ªáu</div>
                            <div class="card-body compact-body d-flex flex-column">
                                <div style="flex:1; overflow-y:auto;">
                                    <table class="table" id="bar-table">
                                        <thead><tr><th>Nh√£n</th><th>Gi√° tr·ªã</th><th width="30"></th></tr></thead>
                                        <tbody></tbody>
                                    </table>
                                </div>
                                <button class="btn btn-sm btn-success w-100 mt-2" onclick="addRow('bar')"><i class="fas fa-plus"></i> Th√™m d√≤ng</button>
                            </div>
                        </div>
                        <div class="d-flex gap-2">
                            <button class="btn btn-primary flex-grow-1" onclick="generateBar()">T·∫°o Code</button>
                            <button class="btn btn-outline-secondary" onclick="copyCode('bar-output')">Copy</button>
                        </div>
                    </div>
                    <div class="col-md-7"><textarea class="form-control h-100" id="bar-output"></textarea></div>
                </div>
            </div>

            <div class="tab-pane fade" id="doublebar">
                <div class="row h-100 g-3">
                    <div class="col-md-5 d-flex flex-column">
                        <div class="card">
                            <div class="card-header"><i class="fas fa-cog"></i> C√†i ƒë·∫∑t</div>
                            <div class="card-body compact-body">
                                <div class="input-group input-group-sm mb-2">
                                    <span class="input-group-text">Ti√™u ƒë·ªÅ</span>
                                    <input type="text" class="form-control" id="doublebar-title">
                                </div>
                                <div class="row g-2 mb-2">
                                    <div class="col-4"><div class="input-group input-group-sm"><span class="input-group-text">Ox</span><input type="text" class="form-control" id="doublebar-xlabel"></div></div>
                                    <div class="col-4"><div class="input-group input-group-sm"><span class="input-group-text">Oy</span><input type="text" class="form-control" id="doublebar-ylabel"></div></div>
                                    <div class="col-4"><div class="input-group input-group-sm"><span class="input-group-text">H·ªá s·ªë</span><input type="text" class="form-control" id="doublebar-oyfactor" value="10"></div></div>
                                </div>
                                <div class="row g-2 mb-2">
                                    <div class="col-6"><div class="input-group input-group-sm"><span class="input-group-text">N1</span><input type="text" class="form-control" id="doublebar-g1name" placeholder="T√™n nh√≥m 1"></div></div>
                                    <div class="col-6"><select class="form-select form-select-sm" id="doublebar-pattern1"><option value=""></option><option value="grid">grid</option><option value="dots">dots</option><option value="north east lines">north east lines</option><option value="bricks">bricks</option><option value="north west lines">north west lines</option></select></div>
                                </div>
                                <div class="row g-2">
                                    <div class="col-6"><div class="input-group input-group-sm"><span class="input-group-text">N2</span><input type="text" class="form-control" id="doublebar-g2name" placeholder="T√™n nh√≥m 2"></div></div>
                                    <div class="col-6"><select class="form-select form-select-sm" id="doublebar-pattern2"><option value=""></option><option value="grid">grid</option><option value="dots">dots</option><option value="north west lines">north east lines</option><option value="bricks">bricks</option><option value="north west lines">north west lines</option></select></div>
                                </div>
                            </div>
                        </div>
                        <div class="card flex-grow-1">
                            <div class="card-header"><i class="fas fa-database"></i> D·ªØ li·ªáu</div>
                            <div class="card-body compact-body d-flex flex-column">
                                <div style="flex:1; overflow-y:auto;">
                                    <table class="table" id="doublebar-table">
                                        <thead><tr><th>Nh√£n</th><th>Gi√° tr·ªã 1</th><th>Gi√° tr·ªã 2</th><th width="30"></th></tr></thead>
                                        <tbody></tbody>
                                    </table>
                                </div>
                                <button class="btn btn-sm btn-success w-100 mt-2" onclick="addRow('doublebar')"><i class="fas fa-plus"></i> Th√™m d√≤ng</button>
                            </div>
                        </div>
                        <div class="d-flex gap-2">
                            <button class="btn btn-primary flex-grow-1" onclick="generateDoubleBar()">T·∫°o Code</button>
                            <button class="btn btn-outline-secondary" onclick="copyCode('doublebar-output')">Copy</button>
                        </div>
                    </div>
                    <div class="col-md-7"><textarea class="form-control h-100" id="doublebar-output"></textarea></div>
                </div>
            </div>

            <div class="tab-pane fade" id="line">
                <div class="row h-100 g-3">
                    <div class="col-md-5 d-flex flex-column">
                        <div class="card">
                            <div class="card-header"><i class="fas fa-cog"></i> C√†i ƒë·∫∑t</div>
                            <div class="card-body compact-body">
                                <div class="input-group input-group-sm mb-2">
                                    <span class="input-group-text">Ti√™u ƒë·ªÅ</span>
                                    <input type="text" class="form-control" id="line-title">
                                </div>
                                <div class="row g-2 mb-2">
                                    <div class="col-4"><div class="input-group input-group-sm"><span class="input-group-text">Ox</span><input type="text" class="form-control" id="line-xlabel"></div></div>
                                    <div class="col-4"><div class="input-group input-group-sm"><span class="input-group-text">Oy</span><input type="text" class="form-control" id="line-ylabel"></div></div>
                                    <div class="col-4"><div class="input-group input-group-sm"><span class="input-group-text">H·ªá s·ªë</span><input type="text" class="form-control" id="line-oyfactor" value="10"></div></div>
                                </div>
                                <div class="row g-2">
                                    <div class="col-4"><div class="input-group input-group-sm"><span class="input-group-text">Line</span><input type="text" class="form-control" id="line-linecolor" placeholder="M√†u"></div></div>
                                    <div class="col-4"><div class="input-group input-group-sm"><span class="input-group-text">Dot</span><input type="text" class="form-control" id="line-pointcolor" placeholder="M√†u"></div></div>
                                    <div class="col-4"><div class="input-group input-group-sm"><span class="input-group-text">D√†y</span><input type="text" class="form-control" id="line-linewidth" value="1.5pt"></div></div>
                                </div>
                            </div>
                        </div>
                        <div class="card flex-grow-1">
                            <div class="card-header"><i class="fas fa-database"></i> D·ªØ li·ªáu</div>
                            <div class="card-body compact-body d-flex flex-column">
                                <div style="flex:1; overflow-y:auto;">
                                    <table class="table" id="line-table">
                                        <thead><tr><th>Nh√£n</th><th>Gi√° tr·ªã</th><th width="30"></th></tr></thead>
                                        <tbody></tbody>
                                    </table>
                                </div>
                                <button class="btn btn-sm btn-success w-100 mt-2" onclick="addRow('line')"><i class="fas fa-plus"></i> Th√™m ƒëi·ªÉm</button>
                            </div>
                        </div>
                        <div class="d-flex gap-2">
                            <button class="btn btn-primary flex-grow-1" onclick="generateLine()">T·∫°o Code</button>
                            <button class="btn btn-outline-secondary" onclick="copyCode('line-output')">Copy</button>
                        </div>
                    </div>
                    <div class="col-md-7"><textarea class="form-control h-100" id="line-output"></textarea></div>
                </div>
            </div>

            <div class="tab-pane fade" id="pictogram">
                <div class="row h-100 g-3">
                    <div class="col-md-5 d-flex flex-column">
                        <div class="card">
                            <div class="card-header"><i class="fas fa-cog"></i> C√†i ƒë·∫∑t</div>
                            <div class="card-body compact-body">
                                <div class="input-group input-group-sm mb-2">
                                    <span class="input-group-text">Ti√™u ƒë·ªÅ</span>
                                    <input type="text" class="form-control" id="pictogram-title">
                                </div>
                                <div class="row g-2 mb-2">
                                    <div class="col-6">
                                        <div class="input-group input-group-sm">
                                            <span class="input-group-text">Icon</span>
                                            <select class="form-select" id="pictogram-icon">
                                                <option value="\faUser">Ng∆∞·ªùi (User)</option>
                                                <option value="\faCar">Xe (Car)</option>
                                                <option value="\faTree">C√¢y (Tree)</option>
                                                <option value="\faStar">Sao (Star)</option>
                                                <option value="\faHeart">Tim (Heart)</option>
                                                <option value="\faSmile">C∆∞·ªùi (Smile)</option>
                                                <option value="\faMusic">Nh·∫°c (Music)</option>
                                                <option value="\faHome">Nh√† (Home)</option>
                                                <option value="\faBook">S√°ch (Book)</option>
                                                <option value="\faAppleAlt">T√°o (Apple)</option>
                                                <option value="\faFish">C√° (Fish)</option>
                                                <option value="\faDog">Ch√≥ (Dog)</option>
                                                <option value="\faCat">M√®o (Cat)</option>
                                                <option value="\faFutbol">B√≥ng ƒë√° (Football)</option>
                                                <option value="\faBicycle">Xe ƒë·∫°p (Bicycle)</option>
                                                <option value="\faBus">Bu√Ωt (Bus)</option>
                                                <option value="\faPlane">M√°y bay (Plane)</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="col-3"><input type="text" class="form-control form-control-sm" id="pictogram-scale" value="1.5" placeholder="T·ª∑ l·ªá"></div>
                                    <div class="col-3"><input type="text" class="form-control form-control-sm" id="pictogram-spacing" value="1.5" placeholder="C√°ch"></div>
                                </div>
                                <div class="row g-2">
                                    <div class="col-6"><div class="input-group input-group-sm"><span class="input-group-text">Full=</span><input type="text" class="form-control" id="pictogram-fullvalue"></div></div>
                                    <div class="col-6"><div class="input-group input-group-sm"><span class="input-group-text">Half=</span><input type="text" class="form-control" id="pictogram-halfvalue"></div></div>
                                </div>
                            </div>
                        </div>
                        <div class="card flex-grow-1">
                            <div class="card-header"><i class="fas fa-database"></i> D·ªØ li·ªáu</div>
                            <div class="card-body compact-body d-flex flex-column">
                                <div style="flex:1; overflow-y:auto;">
                                    <table class="table" id="pictogram-table">
                                        <thead><tr><th>M·ª•c</th><th>Gi√° tr·ªã</th><th width="30"></th></tr></thead>
                                        <tbody></tbody>
                                    </table>
                                </div>
                                <button class="btn btn-sm btn-success w-100 mt-2" onclick="addRow('pictogram')"><i class="fas fa-plus"></i> Th√™m d√≤ng</button>
                            </div>
                        </div>
                        <div class="d-flex gap-2">
                            <button class="btn btn-primary flex-grow-1" onclick="generatePictogram()">T·∫°o Code</button>
                            <button class="btn btn-outline-secondary" onclick="copyCode('pictogram-output')">Copy</button>
                        </div>
                    </div>
                    <div class="col-md-7"><textarea class="form-control h-100" id="pictogram-output"></textarea></div>
                </div>
            </div>
        </div>
    </div>

    <div id="geo-app" class="app-view">
        <div id="geo-toolbar">
            <div class="geo-tool-group">
                <h4><i class="fas fa-dot-circle me-1"></i> ƒêi·ªÉm c∆° b·∫£n</h4>
                <div class="tool-grid">
                    <button id="tool-point" class="active"><i class="fas fa-circle" style="font-size:8px"></i>ƒêi·ªÉm m·ªõi</button>
                    <button id="tool-midpoint"><i class="fas fa-adjust"></i>Trung ƒëi·ªÉm</button>
                    <button id="tool-centroid"><i class="fas fa-bullseye"></i>Tr·ªçng t√¢m</button>
                    <button id="tool-circumcenter"><i class="far fa-circle"></i>Ngo·∫°i ti·∫øp</button>
                    <button id="tool-incenter"><i class="fas fa-bullseye" style="font-size:10px"></i>N·ªôi ti·∫øp</button>
                    <button id="tool-orthocenter"><i class="fas fa-crosshairs"></i>Tr·ª±c t√¢m</button>
                    <button id="tool-point-on-circle"><i class="far fa-dot-circle"></i>ƒêi·ªÉm tr√™n ƒë∆∞·ªùng tr√≤n</button>

                </div>
            </div>

            <div class="geo-tool-group">
                <h4><i class="fas fa-pen-nib me-1"></i> V·∫Ω h√¨nh</h4>
                <div class="tool-grid">
                    <button id="tool-segment"><i class="fas fa-minus"></i>ƒêo·∫°n th·∫≥ng</button>
                    <button id="tool-line"><i class="fas fa-arrows-alt-h"></i>ƒê∆∞·ªùng th·∫≥ng</button>
                    <button id="tool-circle"><i class="far fa-circle"></i>ƒê.Tr√≤n (2 ƒëi·ªÉm)</button>
                    <button id="tool-circle-radius"><i class="fas fa-bullseye"></i>ƒê.Tr√≤n (R)</button>
                    <button id="tool-polygon"><i class="fas fa-draw-polygon"></i>ƒêa gi√°c</button>
                    <button id="tool-arc"><i class="fas fa-wifi" style="transform: rotate(90deg)"></i>Cung tr√≤n</button>
                </div>
            </div>

            <div class="geo-tool-group">
                <h4><i class="fas fa-project-diagram me-1"></i> Quan h·ªá</h4>
                <div class="tool-grid">
                    <button id="tool-perp-bisector"><i class="fas fa-grip-lines-vertical"></i>Trung tr·ª±c</button>
                    <button id="tool-median"><i class="fas fa-slash"></i>Trung tuy·∫øn</button>
                    <button id="tool-altitude"><i class="fas fa-ruler-vertical"></i>ƒê∆∞·ªùng cao</button>
                    <button id="tool-angle-bisector"><i class="fas fa-chevron-right"></i>Ph√¢n gi√°c</button>
                    <button id="tool-perpendicular"><i class="fas fa-l"></i>Vu√¥ng g√≥c</button>
                    <button id="tool-parallel"><i class="fas fa-equals"></i>Song song</button>
                    <button id="tool-intersection-ll"><i class="fas fa-times"></i>Giao 2 ƒë∆∞·ªùng</button>
                    <button id="tool-projection"><i class="fas fa-level-down-alt"></i>H√¨nh chi·∫øu</button>
                </div>
            </div>

            <div class="geo-tool-group">
                <h4><i class="fas fa-magic me-1"></i> Bi·∫øn h√¨nh & Kh√°c</h4>
                <div class="tool-grid">
                    <button id="tool-tangent"><i class="fas fa-external-link-alt"></i>Ti·∫øp tuy·∫øn</button>
                    <button id="tool-inter-cc"><i class="fas fa-link"></i>Giao 2 ƒê.Tr√≤n</button>
                    <button id="tool-sym-point"><i class="fas fa-sync-alt"></i>ƒê·ªëi x·ª©ng t√¢m</button>
                    <button id="tool-sym-line"><i class="fas fa-arrows-alt-h"></i>ƒê·ªëi x·ª©ng tr·ª•c</button>
                    <button id="tool-translation"><i class="fas fa-arrow-right"></i>T·ªãnh ti·∫øn</button>
                </div>
            </div>

            <div class="geo-tool-group">
                <h4><i class="fas fa-paint-brush me-1"></i> Trang tr√≠ & Edit</h4>
                <div class="tool-grid">
                    <button id="tool-fill-polygon"><i class="fas fa-fill"></i>T√¥ ƒëa gi√°c</button>
                    <button id="tool-mark-angle"><i class="fas fa-angle-up"></i>K√Ω hi·ªáu G√≥c</button>
                    <button id="tool-mark-right"><i class="far fa-square"></i>G√≥c vu√¥ng</button>
                    <button id="tool-mark-segment"><i class="fas fa-slash"></i>K√Ω hi·ªáu ƒêo·∫°n</button>
                    <button id="tool-label"><i class="fas fa-font"></i>ƒê·ªïi t√™n ƒëi·ªÉm</button>
                    <button id="tool-move" style="color:var(--primary)"><i class="fas fa-hand-paper"></i>Di chuy·ªÉn</button>
                    <button id="tool-delete" style="color:#ef4444"><i class="fas fa-trash"></i>X√≥a ƒë·ªëi t∆∞·ª£ng</button>
                </div>
            </div>
            
            <div class="p-3">
                <button class="btn btn-sm btn-outline-secondary w-100 mb-2" id="toggle-grid">üî≤ L∆∞·ªõi</button>
                <button class="btn btn-sm btn-outline-secondary w-100 mb-2" id="toggle-snap">üß≤ Snap</button>
                <button class="btn btn-sm btn-danger w-100" id="clear">üóëÔ∏è X√≥a h·∫øt</button>
            </div>
        </div>

        <div id="geo-main-area">
            <div id="geo-controls">
                <button class="btn btn-sm btn-outline-primary fw-bold" id="btn-fullscreen" title="M·ªü r·ªông v√πng v·∫Ω">
                    <i class="fas fa-expand me-1"></i> M·ªü r·ªông
                </button>
                <div style="width: 1px; height: 20px; background: var(--border); margin: 0 5px;"></div>
                
                <div class="ctrl-group">
                    <span class="fw-bold text-secondary">N√©t:</span>
                    <input type="color" id="color" value="#1f2937">
                    <input type="number" class="form-control form-control-sm" id="thickness" value="2" min="1" max="8" style="width:50px">
                    <select id="line-style" class="form-select form-select-sm" style="width:auto">
                        <option value="solid">Li·ªÅn</option>
                        <option value="dashed">ƒê·ª©t</option>
                        <option value="dotted">Ch·∫•m</option>
                    </select>
                </div>
                <div class="ctrl-group">
                    <span class="fw-bold text-secondary">T√¥:</span>
                    <input type="color" id="fill-color" value="#93c5fd">
                    <input type="range" id="opacity" min="0" max="100" value="30" style="width:70px" title="ƒê·ªô m·ªù">
                </div>
                <div class="ctrl-group">
                    <span class="fw-bold text-secondary">Mark:</span>
                    <select id="mark-style" class="form-select form-select-sm" style="width:auto" title="Ki·ªÉu ƒë√°nh d·∫•u">
                        <option value="|">|</option>
                        <option value="||">||</option>
                        <option value="|||">|||</option>
                        <option value="z">z</option>
                        <option value="s">s</option>
                        <option value="x">x</option>
                        <option value="o">o</option>
                    </select>
                </div>
            </div>
            
            <div id="geo-canvas-container">
                <canvas id="geo-canvas"></canvas>
            </div>
        </div>

        <div id="geo-code-panel">
            <div id="geo-code-header">
                <span><i class="fas fa-code me-2 text-primary"></i>M√É TKZ-EUCLIDE</span>
                <span class="badge bg-secondary" style="font-size:10px">ReadOnly</span>
            </div>
            <textarea id="geo-code" readonly spellcheck="false"></textarea>
            <div id="geo-code-footer">Copy m√£ n√†y d√°n v√†o Overleaf ho·∫∑c TeX editor</div>
        </div>
    </div>
</div>

<div class="geo-status" id="geo-status">Th√¥ng b√°o</div>
<div id="geo-modal">
    <div class="geo-modal-box">
        <h5 id="geo-modal-title" style="color:var(--primary); margin-bottom:15px; font-weight:700;">Nh·∫≠p d·ªØ li·ªáu</h5>
        <input type="text" class="form-control mb-4" id="geo-modal-input" placeholder="Gi√° tr·ªã..." style="border: 1px solid var(--primary); padding:10px;">
        <div class="d-flex justify-content-end gap-2">
            <button class="btn btn-sm btn-secondary" id="geo-modal-cancel">H·ªßy</button>
            <button class="btn btn-sm btn-primary" id="geo-modal-ok">ƒê·ªìng √Ω</button>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

<script>
    // --- APP SWITCHING LOGIC ---
    function switchApp(app) {
        document.querySelectorAll('.app-view').forEach(e => e.classList.remove('active'));
        document.querySelectorAll('.menu-item').forEach(e => e.classList.remove('active'));
        
        if (app === 'chart') {
            document.getElementById('chart-app').classList.add('active');
            document.getElementById('btn-chart').classList.add('active');
            document.getElementById('page-title').innerText = 'Bi·ªÉu ƒë·ªì LaTeX';
            document.getElementById('geo-header-actions').style.display = 'none';
        } else {
            document.getElementById('geo-app').classList.add('active');
            document.getElementById('btn-geo').classList.add('active');
            document.getElementById('page-title').innerText = 'H√¨nh h·ªçc tkz-euclide';
            document.getElementById('geo-header-actions').style.display = 'flex';
            if (window.geo_resize) window.geo_resize();
        }
    }
    
    window.addEventListener('resize', () => {
        if (document.getElementById('geo-app').classList.contains('active') && window.geo_resize) {
            window.geo_resize();
        }
    });

    // --- FULLSCREEN TOGGLE LOGIC ---
    const btnFullscreen = document.getElementById('btn-fullscreen');
    if(btnFullscreen) {
        btnFullscreen.addEventListener('click', function() {
            document.body.classList.toggle('fullscreen-mode');
            const isFull = document.body.classList.contains('fullscreen-mode');
            this.innerHTML = isFull ? '<i class="fas fa-compress me-1"></i> Thu nh·ªè' : '<i class="fas fa-expand me-1"></i> M·ªü r·ªông';
            this.className = isFull ? 'btn btn-sm btn-primary fw-bold' : 'btn btn-sm btn-outline-primary fw-bold';
            setTimeout(() => {
                if (window.geo_resize) window.geo_resize();
            }, 100);
        });
    }
</script>

<script>
    // --- CHART LOGIC (GI·ªÆ NGUY√äN) ---
    const PATTERNS = ["", "grid", "dots", "bricks", "crosshatch", "north east lines", "north west lines", "vertical lines", "horizontal lines", "checkerboard", "fivepointed stars", "sixpointed stars"];

    window.onload = function() {
        addRow('pie'); addRow('bar'); addRow('doublebar'); addRow('line'); addRow('line'); addRow('pictogram');
    };

    function addRow(type) {
        const table = document.getElementById(type + '-table').querySelector('tbody');
        const row = document.createElement('tr');
        if (type === 'pie') {
            row.innerHTML = `<td><input type="text" class="form-control form-control-sm"></td><td><input type="text" class="form-control form-control-sm" onkeyup="updatePieSum()"></td><td><select class="form-select form-select-sm">${PATTERNS.map(p => `<option>${p}</option>`).join('')}</select></td><td><button class="btn btn-danger btn-sm" onclick="deleteRow(this, 'pie')"><i class="fas fa-trash"></i></button></td>`;
        } else if (type === 'bar' || type === 'line' || type === 'pictogram') {
            row.innerHTML = `<td><input type="text" class="form-control form-control-sm"></td><td><input type="text" class="form-control form-control-sm"></td><td><button class="btn btn-danger btn-sm" onclick="deleteRow(this, '${type}')"><i class="fas fa-trash"></i></button></td>`;
        } else if (type === 'doublebar') {
            row.innerHTML = `<td><input type="text" class="form-control form-control-sm"></td><td><input type="text" class="form-control form-control-sm"></td><td><input type="text" class="form-control form-control-sm"></td><td><button class="btn btn-danger btn-sm" onclick="deleteRow(this, 'doublebar')"><i class="fas fa-trash"></i></button></td>`;
        }
        table.appendChild(row);
        if (type === 'pie') updatePieSum();
    }

    function deleteRow(btn, type) {
        const table = document.getElementById(type + '-table').querySelector('tbody');
        if (table.rows.length <= 1) { alert('Ph·∫£i c√≥ √≠t nh·∫•t m·ªôt d√≤ng!'); return; }
        if (type === 'line' && table.rows.length <= 2) { alert('Bi·ªÉu ƒë·ªì ƒë∆∞·ªùng c·∫ßn √≠t nh·∫•t hai ƒëi·ªÉm!'); return; }
        btn.parentElement.parentElement.remove();
        if (type === 'pie') updatePieSum();
    }

    function updatePieSum() {
        const table = document.getElementById('pie-table').querySelector('tbody');
        let total = 0;
        Array.from(table.rows).forEach(row => { total += parseFloat(row.cells[1].querySelector('input').value) || 0; });
        document.getElementById('pie-sum').textContent = `T·ªïng: ${total.toFixed(1)}%`;
    }

    function generatePie() {
        const title = document.getElementById('pie-title').value.trim();
        const table = document.getElementById('pie-table').querySelector('tbody');
        const data = [];
        Array.from(table.rows).forEach(row => {
            const nd = row.cells[0].querySelector('input').value.trim();
            const pt = parseFloat(row.cells[1].querySelector('input').value);
            const kh = row.cells[2].querySelector('select').value;
            if (nd && !isNaN(pt) && kh) data.push({nd, pt, kh});
        });
        if (data.length === 0) { alert('Vui l√≤ng nh·∫≠p d·ªØ li·ªáu h·ª£p l·ªá'); return; }
        let code = ['\\begin{tikzpicture}', '\\def\\r{3}', '\\def\\gocxp{90}', '\\coordinate (A) at (90:\\r);'];
        if (title) code.push(`\\node at (0, \\r+0.75) [align=center, text width=10cm] {\\textbf{${title}}};`);
        code.push('\\foreach \\nd/\\pt/\\kh[count=\\i from 0] in{');
        code.push(data.map(d => `${d.nd}/${d.pt}/${d.kh}`).join(',\n') + '}');
        code.push('{\\pgfmathsetmacro\\gockt{-(\\pt*3.6-\\gocxp)}');
        code.push('\\pgfmathsetmacro\\gocnode{\\gocxp+\\gockt}');
        code.push('\\draw[gray,pattern=\\kh] (0,0)--(A) arc(\\gocxp:\\gockt:\\r) coordinate(A)--cycle;');
        code.push('\\filldraw[pattern=\\kh] (\\r+1,\\r-1.5*\\i-0.75) --++(0:.75)--++(-90:.5) node[pos=.5,right,black]{\\nd}--++(180:.75)--cycle;');
        code.push('\\path ($ (0,0)+(\\gocnode/2:2)$) node[fill=white,inner sep=0pt]{\\color{black} $\\pt\\%$};');
        code.push('\\global\\let\\gocxp=\\gockt}');
        code.push('\\end{tikzpicture}');
        document.getElementById('pie-output').value = code.join('\n');
    }

    function generateBar() {
        const title = document.getElementById('bar-title').value.trim();
        const xlabel = document.getElementById('bar-xlabel').value.trim() || '';
        const ylabel = document.getElementById('bar-ylabel').value.trim() || '';
        const oyfactor = parseInt(document.getElementById('bar-oyfactor').value) || 10;
        const color = document.getElementById('bar-color').value.trim() || 'blue!60';
        const table = document.getElementById('bar-table').querySelector('tbody');
        const data = [];
        Array.from(table.rows).forEach(row => {
            const nd = row.cells[0].querySelector('input').value.trim();
            const gt = parseFloat(row.cells[1].querySelector('input').value);
            if (nd && !isNaN(gt)) data.push({nd, gt});
        });
        if (data.length === 0 || oyfactor === 0) { alert('D·ªØ li·ªáu ho·∫∑c h·ªá s·ªë kh√¥ng h·ª£p l·ªá'); return; }
        const processed = data.map(d => ({name: d.nd, height: d.gt / oyfactor, value: d.gt}));
        const maxHeight = Math.max(...processed.map(p => p.height));
        const maxAxis = Math.floor(maxHeight) + 1;
        const yHeight = maxAxis + 1;
        const lastX = 2 * data.length - 1;
        const width = lastX + 2;
        const titleX = (1 + lastX) / 2;
        let code = ['\\begin{tikzpicture}[font=\\footnotesize, yscale=0.75]', `  \\draw[->] (0,0)--(${width},0) node[below]{{\\shortstack{${xlabel}}}};`, `  \\draw[->] (0,0) node [left] {0} -- (0,${yHeight}) node[left]{{\\shortstack{${ylabel}}}};`, `  \\foreach \\y in {1,...,${maxAxis}}{\\draw[gray!30] (${width},\\y) -- (0,\\y) node [left,black] {\\the\\numexpr ${oyfactor}*\\y};}`];
        code.push('  \\foreach \\x/\\t/\\y/\\z in {');
        code.push(processed.map((p, i) => `    ${2*(i+1)-1}/${p.name}/${p.height}/${p.value}`).join(',\n'));
        code.push('}{');
        code.push('    \\node at (\\x,0) [below] {\\t};');
        code.push(`    \\filldraw [fill=${color}] (\\x-0.5,0) rectangle (\\x+0.5,\\y);`);
        code.push('    \\node at (\\x,\\y) [above] {\\pgfmathprintnumber[1000 sep={},dec sep={,}]{\\z}};');
        code.push('  }');
        if (title) code.push(`  \\node at (${titleX}, ${yHeight+1}) [align=center, text width=10cm] {\\textbf{${title}}};`);
        code.push('\\end{tikzpicture}');
        document.getElementById('bar-output').value = code.join('\n');
    }

    function generateDoubleBar() {
        const title = document.getElementById('doublebar-title').value.trim();
        const xlabel = document.getElementById('doublebar-xlabel').value.trim() || 'ƒê·ªëi t∆∞·ª£ng';
        const ylabel = document.getElementById('doublebar-ylabel').value.trim() || 'Gi√° tr·ªã';
        const oyfactor = parseInt(document.getElementById('doublebar-oyfactor').value) || 10;
        const g1name = document.getElementById('doublebar-g1name').value.trim() || 'Nh√≥m 1';
        const g2name = document.getElementById('doublebar-g2name').value.trim() || 'Nh√≥m 2';
        const pat1 = document.getElementById('doublebar-pattern1').value;
        const pat2 = document.getElementById('doublebar-pattern2').value;
        const table = document.getElementById('doublebar-table').querySelector('tbody');
        const data = [];
        Array.from(table.rows).forEach(row => {
            const nd = row.cells[0].querySelector('input').value.trim();
            const v1 = parseFloat(row.cells[1].querySelector('input').value);
            const v2 = parseFloat(row.cells[2].querySelector('input').value);
            if (nd && !isNaN(v1) && !isNaN(v2)) data.push({nd, v1, v2});
        });
        if (data.length === 0 || oyfactor === 0) { alert('D·ªØ li·ªáu ho·∫∑c h·ªá s·ªë kh√¥ng h·ª£p l·ªá'); return; }
        const pat1Str = pat1 ? `pattern=${pat1}` : 'draw'; const pat2Str = pat2 ? `pattern=${pat2}` : 'draw';
        const processed = data.map(d => ({name: d.nd, h1: d.v1 / oyfactor, val1: d.v1, h2: d.v2 / oyfactor, val2: d.v2}));
        const maxHeight = Math.max(...processed.map(p => Math.max(p.h1, p.h2)));
        const maxAxis = Math.floor(maxHeight) + 1;
        const yHeight = maxAxis + 1;
        const lastX = 2 * data.length - 1;
        const width = lastX + 2;
        const titleX = (1 + lastX) / 2;
        let code = ['\\begin{tikzpicture}[font=\\footnotesize, yscale=0.75, xscale=1.2]', `  \\draw[->] (0,0)--(${width},0) node[below]{{\\shortstack{${xlabel}}}};`, `  \\draw[->] (0,0)--(0,${yHeight}) node[left]{{\\shortstack{${ylabel}}}};`, `  \\foreach \\y in {0,1,...,${maxAxis}}{\\draw (0.1,\\y) -- (-0.1,\\y) node [left] {\\the\\numexpr ${oyfactor}*\\y};}`];
        code.push('  % Bi·ªÉu ƒë·ªì c·ªôt k√©p');
        code.push('  \\foreach \\x/\\t/\\y/\\z/\\u/\\v in {');
        code.push(processed.map((p, i) => `    ${2*(i+1)-1}/${p.name}/${p.h1}/${p.val1}/${p.h2}/${p.val2}`).join(',\n'));
        code.push('}{');
        code.push('    \\node at (\\x,0) [below] {\\t};');
        code.push(`    \\draw [${pat1Str}] (\\x-0.6,0) rectangle (\\x-0.05,\\y);`);
        code.push('    \\node at (\\x-0.35,\\y) [above] {\\pgfmathprintnumber[1000 sep={},dec sep={,}]{\\z}};');
        code.push(`    \\draw [${pat2Str}] (\\x+0.05,0) rectangle (\\x+0.6,\\u);`);
        code.push('    \\node at (\\x+0.35,\\u) [above] {\\pgfmathprintnumber[1000 sep={},dec sep={,}]{\\v}};');
        code.push('  }');
        if (title) code.push(`  \\node at (${titleX}, ${yHeight+1}) [align=center, text width=10cm] {\\textbf{${title}}};`);
        code.push(`  \\matrix[right] at (${width+1},${yHeight/2}) [column sep=5pt, row sep=4pt] { \\node[draw,${pat1Str},minimum width=12pt,minimum height=12pt] {}; & \\node {${g1name}}; \\\\ \\node[draw,${pat2Str},minimum width=12pt,minimum height=12pt] {}; & \\node {${g2name}}; \\\\ };`);
        code.push('\\end{tikzpicture}');
        document.getElementById('doublebar-output').value = code.join('\n');
    }

    function generateLine() {
        const title = document.getElementById('line-title').value.trim();
        const xlabel = document.getElementById('line-xlabel').value.trim() || '';
        const ylabel = document.getElementById('line-ylabel').value.trim() || '';
        const oyfactor = parseInt(document.getElementById('line-oyfactor').value) || 10;
        const linecolor = document.getElementById('line-linecolor').value.trim() || '';
        const pointcolor = document.getElementById('line-pointcolor').value.trim() || '';
        const linewidth = document.getElementById('line-linewidth').value.trim() || '1.5pt';
        const table = document.getElementById('line-table').querySelector('tbody');
        const data = [];
        Array.from(table.rows).forEach(row => {
            const nd = row.cells[0].querySelector('input').value.trim();
            const gt = parseFloat(row.cells[1].querySelector('input').value);
            if (nd && !isNaN(gt)) data.push({nd, gt});
        });
        if (data.length < 2 || oyfactor === 0) { alert('D·ªØ li·ªáu ho·∫∑c h·ªá s·ªë kh√¥ng h·ª£p l·ªá. C·∫ßn √≠t nh·∫•t 2 ƒëi·ªÉm.'); return; }
        const processed = data.map((d, i) => ({x: 2*(i+1), name: d.nd, y: d.gt / oyfactor, value: d.gt}));
        const maxY = Math.max(...processed.map(p => p.y));
        const maxAxis = Math.floor(maxY) + 2;
        const yHeight = maxAxis + 1;
        const lastX = processed[processed.length - 1].x;
        const width = lastX + 2;
        const titleX = width / 2;
        let code = ['\\begin{tikzpicture}[font=\\footnotesize, yscale=0.8]', `  \\draw[->] (0,0)--(${width},0) node[below]{${xlabel}};`, `  \\draw[->] (0,0)--(0,${yHeight}) node[left]{${ylabel}};`, `  \\foreach \\y in {0,1,...,${maxAxis}}{\\draw (0.1,\\y) -- (-0.1,\\y) node [left] {\\the\\numexpr ${oyfactor}*\\y};}`];
        code.push('  \\foreach \\x/\\t/\\y/\\z in {');
        code.push(processed.map(p => `    ${p.x}/${p.name}/${p.y}/${p.value}`).join(',\n'));
        code.push('}{');
        code.push('    \\draw [dashed, gray!50] (\\x,\\y) -- (\\x,0) node [below,black] {\\t};');
        code.push('    \\pgfmathsetmacro\\kq{\\z}');
        code.push(`    \\filldraw [${pointcolor}] (\\x,\\y) circle (2.5pt);`);
        code.push('    \\pgfmathsetmacro\\yoffset{(\\y < 3) ? -0.4 : 0.4}');
        code.push('    \\node at (\\x,\\y+\\yoffset) {\\pgfmathprintnumber[1000 sep={},dec sep={,}]{\\kq}};');
        code.push('  }');
        const lineSegments = [];
        for (let i = 1; i < processed.length; i++) { lineSegments.push(`(${processed[i-1].x},${processed[i-1].y}) -- (${processed[i].x},${processed[i].y})`); }
        if (lineSegments.length) { code.push(`  \\draw [${linecolor}, line width=${linewidth}] ${lineSegments.join(' -- ')};`); }
        if (title) code.push(`  \\node at (${titleX}, ${yHeight+0.8}) [align=center, text width=10cm] {\\textbf{${title}}};`);
        code.push('\\end{tikzpicture}');
        document.getElementById('line-output').value = code.join('\n');
    }

    function generatePictogram() {
        const title = document.getElementById('pictogram-title').value.trim();
        const icon = document.getElementById('pictogram-icon').value;
        const scale = parseFloat(document.getElementById('pictogram-scale').value) || 1.5;
        const spacing = parseFloat(document.getElementById('pictogram-spacing').value) || 1.5;
        const fullVal = document.getElementById('pictogram-fullvalue').value || '1';
        const halfVal = document.getElementById('pictogram-halfvalue').value || '0.5';
        const table = document.getElementById('pictogram-table').querySelector('tbody');
        const data = [];
        Array.from(table.rows).forEach(row => {
            const name = row.cells[0].querySelector('input').value.trim();
            const value = parseFloat(row.cells[1].querySelector('input').value);
            if (name && !isNaN(value)) data.push({name, value});
        });
        if (data.length === 0) { alert('Vui l√≤ng nh·∫≠p d·ªØ li·ªáu h·ª£p l·ªá'); return; }
        const numRows = data.length; const rowHeight = 1.8; const colWidth = 4; const totalHeight = numRows * rowHeight;
        const maxValue = Math.max(...data.map(d => d.value)); const maxIcons = Math.floor(maxValue) + (maxValue % 1 >= 0.5 ? 1 : 0);
        const totalWidth = colWidth + maxIcons * spacing + 2;
        let code = ['\\begin{tikzpicture}'];
        if (title) code.push(`\\node at (${totalWidth/2},${totalHeight+1}) {\\Large\\textbf{${title}}};`);
        code.push(`\\draw (0,0) rectangle (${totalWidth},${totalHeight});`);
        code.push(`\\draw (${colWidth},0) -- (${colWidth},${totalHeight});`);
        if (numRows > 1) { for (let i = 1; i < numRows; i++) { code.push(`\\draw (0,${i*rowHeight}) -- (${totalWidth},${i*rowHeight});`); } }
        code.push('% Data');
        code.push('\\foreach \\name/\\s/\\y in {');
        code.push(data.map((d, i) => `${d.name.replace(/ /g, '~')}/${d.value}/${totalHeight - (i + 0.5) * rowHeight}`).join(','));
        code.push('} {');
        code.push('  \\node at (2,\\y) {\\name};');
        code.push('  \\pgfmathtruncatemacro{\\full}{floor(\\s)}');
        code.push('  \\pgfmathsetmacro{\\hasHalf}{mod(\\s,1) >= 0.5 ? 1 : 0}');
        code.push('  \\foreach \\i in {1,...,\\full} {');
        code.push(`    \\pgfmathsetmacro{\\xx}{${colWidth}+${spacing}*\\i}`);
        code.push(`    \\node[scale=${scale}] at (\\xx,\\y) {${icon}};`);
        code.push('  }');
        code.push('  \\pgfmathparse{int(\\hasHalf)}');
        code.push('  \\ifnum\\pgfmathresult=1');
        code.push(`    \\pgfmathsetmacro{\\xx}{${colWidth}+${spacing}*(\\full+1)}`);
        code.push('    \\begin{scope}');
        code.push(`      \\clip (\\xx-${spacing*0.3},\\y-0.6) rectangle (\\xx,\\y+0.6);`);
        code.push(`      \\node[scale=${scale}] at (\\xx,\\y) {${icon}};`);
        code.push('    \\end{scope}');
        code.push('  \\fi');
        code.push('}');
        code.push('% Legend');
        code.push(`\\node[scale=${scale}] at (${totalWidth/2-2},-1.5) {${icon}};`);
        code.push(`\\node at (${totalWidth/2-1},-1.5) {= ${fullVal}};`);
        code.push('\\begin{scope}');
        code.push(`  \\clip (${totalWidth/2+0.7},-2.1) rectangle (${totalWidth/2+1},-0.9);`);
        code.push(`  \\node[scale=${scale}] at (${totalWidth/2+1},-1.5) {${icon}};`);
        code.push('\\end{scope}');
        code.push(`\\node at (${totalWidth/2+2},-1.5) {= ${halfVal}};`);
        code.push('\\end{tikzpicture}');
        document.getElementById('pictogram-output').value = code.join('\n');
    }
    function copyCode(id) { const t=document.getElementById(id); t.select(); document.execCommand('copy'); alert('ƒê√£ sao ch√©p!'); }
</script>

<script>
// --- GEOMETRY APP (Extended Pro Version) ---
(function(){
    const canvas = document.getElementById('geo-canvas');
    const ctx = canvas.getContext('2d');
    const codeEl = document.getElementById('geo-code');
    const statusEl = document.getElementById('geo-status');
    
    const SCALE = 50;
    const SNAP = 12;
    let W = canvas.width;
    let H = canvas.height;
    
    // Mouse state
    let mousePos = { x: 0, y: 0 };

    window.geo_resize = function() {
        const container = document.getElementById('geo-canvas-container');
        if(container && container.clientWidth > 0) {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            W = canvas.width;
            H = canvas.height;
            draw();
        }
    }

    let tool = 'point';
    let temp = [];
    let moving = null;
    let showGrid = true;
    let snapToGrid = true;

    // --- MAIN STATE STORE ---
    let state = {
        points: [], segments: [], lines: [], circles: [], circleRadii: [], arcs: [], polygons: [], labels: [],
        midpoints: [], centroids: [], circumcenters: [], incenters: [], orthocenters: [], 
        intersections: [], intersectionsCC: [], projections: [],
        perpBisectors: [], medians: [], altitudes: [], angleBisectors: [], perpendiculars: [], parallels: [],
        tangents: [], symPoints: [], symLines: [], translations: [],
        fills: [], fillCircles: [], clips: [], markAngles: [], markRights: [], markSegments: [], labelSegments: [], labelAngles: []
    };

    let history = [JSON.parse(JSON.stringify(state))];
    let historyIndex = 0;

    function getPointerPos(e) {
        const rect = canvas.getBoundingClientRect();
        let clientX = e.clientX;
        let clientY = e.clientY;
        if (e.touches && e.touches.length > 0) { clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; } 
        else if (e.changedTouches && e.changedTouches.length > 0) { clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; }
        return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function showStatus(msg) {
        statusEl.textContent = msg;
        statusEl.style.display = 'block';
        setTimeout(() => statusEl.style.display = 'none', 2500);
    }

    function save() {
        historyIndex++;
        history = history.slice(0, historyIndex);
        history.push(JSON.parse(JSON.stringify(state)));
        document.getElementById('geo-undo').disabled = false;
        document.getElementById('geo-redo').disabled = true;
    }

    function findPoint(x, y) {
        for (let p of state.points) { if (Math.hypot(p.x - x, p.y - y) < SNAP) return p; }
        return null;
    }

    function snapPoint(x, y) {
        if (!snapToGrid) return { x, y };
        return { x: Math.round(x / SCALE) * SCALE, y: Math.round(y / SCALE) * SCALE };
    }

    function newName() {
        let idx = state.points.length;
        let name = String.fromCharCode(65 + (idx % 26));
        if (idx >= 26) name += Math.floor(idx / 26);
        while (state.points.find(p => p.name === name)) {
            idx++;
            name = String.fromCharCode(65 + (idx % 26));
            if (idx >= 26) name += Math.floor(idx / 26);
        }
        return name;
    }

    function toTikZ(x, y) {
        const tx = (x - W / 2) / SCALE;
        const ty = (H / 2 - y) / SCALE;
        return `(${tx.toFixed(2)},${ty.toFixed(2)})`;
    }

    // --- MATH HELPERS ---
    function calcMid(p1, p2) { return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 }; }
    function calcCentroid(p1, p2, p3) { return { x: (p1.x + p2.x + p3.x) / 3, y: (p1.y + p2.y + p3.y) / 3 }; }
    function calcCircumcenter(p1, p2, p3) {
        const d = 2 * (p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y));
        if (Math.abs(d) < 1e-6) return null;
        const ux = ((p1.x * p1.x + p1.y * p1.y) * (p2.y - p3.y) + (p2.x * p2.x + p2.y * p2.y) * (p3.y - p1.y) + (p3.x * p3.x + p3.y * p3.y) * (p1.y - p2.y)) / d;
        const uy = ((p1.x * p1.x + p1.y * p1.y) * (p3.x - p2.x) + (p2.x * p2.x + p2.y * p2.y) * (p1.x - p3.x) + (p3.x * p3.x + p3.y * p3.y) * (p2.x - p1.x)) / d;
        return { x: ux, y: uy };
    }
    function calcIncenter(p1, p2, p3) {
        const a = Math.hypot(p2.x - p3.x, p2.y - p3.y);
        const b = Math.hypot(p1.x - p3.x, p1.y - p3.y);
        const c = Math.hypot(p1.x - p2.x, p1.y - p2.y);
        const p = a + b + c;
        return { x: (a * p1.x + b * p2.x + c * p3.x) / p, y: (a * p1.y + b * p2.y + c * p3.y) / p };
    }
    function calcOrthocenter(p1, p2, p3) {
        const dx1 = p2.x - p3.x, dy1 = p2.y - p3.y;
        const dx2 = p1.x - p3.x, dy2 = p1.y - p3.y;
        if (Math.abs(dy1) < 1e-6) return { x: p1.x, y: p3.y };
        if (Math.abs(dy2) < 1e-6) return { x: p2.x, y: p3.y };
        const s1 = -dx1 / dy1, s2 = -dx2 / dy2;
        const c1 = p1.y - s1 * p1.x, c2 = p2.y - s2 * p2.x;
        if (Math.abs(s1 - s2) < 1e-6) return null;
        const x = (c2 - c1) / (s1 - s2);
        const y = s1 * x + c1;
        return { x, y };
    }
    function calcProjection(point, lineP1, lineP2) {
        const dx = lineP2.x - lineP1.x, dy = lineP2.y - lineP1.y;
        const lenSq = dx * dx + dy * dy;
        if (lenSq < 1e-6) return lineP1;
        const param = ((point.x - lineP1.x) * dx + (point.y - lineP1.y) * dy) / lenSq;
        return { x: lineP1.x + param * dx, y: lineP1.y + param * dy };
    }
    function calcIntersectionLines(l1p1, l1p2, l2p1, l2p2) {
        const d1x = l1p2.x - l1p1.x, d1y = l1p2.y - l1p1.y;
        const d2x = l2p2.x - l2p1.x, d2y = l2p2.y - l2p1.y;
        const det = d1x * d2y - d1y * d2x;
        if (Math.abs(det) < 1e-6) return null;
        const t = ((l2p1.x - l1p1.x) * d2y - (l2p1.y - l1p1.y) * d2x) / det;
        return { x: l1p1.x + t * d1x, y: l1p1.y + t * d1y };
    }
    function calcIntersectionCircleLine(center, radius, lineP1, lineP2) {
        const dx = lineP2.x - lineP1.x, dy = lineP2.y - lineP1.y;
        const fx = lineP1.x - center.x, fy = lineP1.y - center.y;
        const a = dx * dx + dy * dy;
        const b = 2 * (fx * dx + fy * dy);
        const c = fx * fx + fy * fy - radius * radius;
        const disc = b * b - 4 * a * c;
        if (disc < 0) return [];
        if (Math.abs(disc) < 1e-6) {
            const t = -b / (2 * a);
            return [{ x: lineP1.x + t * dx, y: lineP1.y + t * dy }];
        }
        const t1 = (-b + Math.sqrt(disc)) / (2 * a);
        const t2 = (-b - Math.sqrt(disc)) / (2 * a);
        return [{ x: lineP1.x + t1 * dx, y: lineP1.y + t1 * dy }, { x: lineP1.x + t2 * dx, y: lineP1.y + t2 * dy }];
    }
    // NEW: Intersection Circle-Circle
    function calcIntersectionCC(c1, r1, c2, r2) {
        const dx = c2.x - c1.x, dy = c2.y - c1.y;
        const d = Math.hypot(dx, dy);
        if (d > r1 + r2 || d < Math.abs(r1 - r2) || d === 0) return [];
        const a = (r1*r1 - r2*r2 + d*d) / (2*d);
        const h = Math.sqrt(Math.max(0, r1*r1 - a*a));
        const x2 = c1.x + a * (dx/d);
        const y2 = c1.y + a * (dy/d);
        return [
            { x: x2 + h * (dy/d), y: y2 - h * (dx/d) },
            { x: x2 - h * (dy/d), y: y2 + h * (dx/d) }
        ];
    }
    // NEW: Tangent
    function calcTangent(pt, center, radius) {
        const dx = center.x - pt.x, dy = center.y - pt.y;
        const d = Math.hypot(dx, dy);
        if (d < radius) return []; // Point inside circle
        const angle = Math.atan2(dy, dx);
        const offset = Math.acos(radius / d);
        return [
            { x: center.x - radius * Math.cos(angle + offset), y: center.y - radius * Math.sin(angle + offset) },
            { x: center.x - radius * Math.cos(angle - offset), y: center.y - radius * Math.sin(angle - offset) }
        ];
    }
    // NEW: Transformations
    function calcSymPoint(center, pt) { return { x: 2*center.x - pt.x, y: 2*center.y - pt.y }; }
    function calcTranslation(pt, v1, v2) { return { x: pt.x + (v2.x - v1.x), y: pt.y + (v2.y - v1.y) }; }

    function updateDependentPoints() {
        state.midpoints.forEach(item => { const p = calcMid(item.p1, item.p2); item.result.x = p.x; item.result.y = p.y; });
        state.centroids.forEach(item => { const p = calcCentroid(item.p1, item.p2, item.p3); item.result.x = p.x; item.result.y = p.y; });
        state.circumcenters.forEach(item => { const p = calcCircumcenter(item.p1, item.p2, item.p3); if(p){item.result.x = p.x; item.result.y = p.y;} });
        state.incenters.forEach(item => { const p = calcIncenter(item.p1, item.p2, item.p3); item.result.x = p.x; item.result.y = p.y; });
        state.orthocenters.forEach(item => { const p = calcOrthocenter(item.p1, item.p2, item.p3); if(p){item.result.x = p.x; item.result.y = p.y;} });
        state.projections.forEach(item => { const p = calcProjection(item.point, item.lp1, item.lp2); item.result.x = p.x; item.result.y = p.y; });
        
        state.intersections.forEach(item => {
            if (item.type === 'll') { const p = calcIntersectionLines(item.l1p1, item.l1p2, item.l2p1, item.l2p2); if(p){item.result.x = p.x; item.result.y = p.y;} }
            else if (item.type === 'cl') {
                const r = Math.hypot(item.pointOnCircle.x - item.center.x, item.pointOnCircle.y - item.center.y);
                const ps = calcIntersectionCircleLine(item.center, r, item.lp1, item.lp2);
                if (ps.length > 0 && item.result1) { item.result1.x = ps[0].x; item.result1.y = ps[0].y; }
                if (ps.length > 1 && item.result2) { item.result2.x = ps[1].x; item.result2.y = ps[1].y; }
            }
        });
        
        // NEW UPDATES
        state.intersectionsCC.forEach(item => {
            const r1 = Math.hypot(item.c1r.x - item.c1.x, item.c1r.y - item.c1.y);
            const r2 = Math.hypot(item.c2r.x - item.c2.x, item.c2r.y - item.c2.y);
            const ps = calcIntersectionCC(item.c1, r1, item.c2, r2);
            if(ps.length > 0 && item.res1) { item.res1.x = ps[0].x; item.res1.y = ps[0].y; }
            if(ps.length > 1 && item.res2) { item.res2.x = ps[1].x; item.res2.y = ps[1].y; }
        });

        state.tangents.forEach(item => {
            const r = Math.hypot(item.cr.x - item.c.x, item.cr.y - item.c.y);
            const ps = calcTangent(item.pt, item.c, r);
            if(ps.length > 0) { item.t1.x = ps[0].x; item.t1.y = ps[0].y; }
            if(ps.length > 1) { item.t2.x = ps[1].x; item.t2.y = ps[1].y; }
        });

        state.symPoints.forEach(item => { const p = calcSymPoint(item.center, item.pt); item.res.x = p.x; item.res.y = p.y; });
        state.symLines.forEach(item => { 
            const proj = calcProjection(item.pt, item.lp1, item.lp2);
            item.res.x = 2*proj.x - item.pt.x; item.res.y = 2*proj.y - item.pt.y;
        });
        state.translations.forEach(item => { const p = calcTranslation(item.pt, item.v1, item.v2); item.res.x = p.x; item.res.y = p.y; });
        
        // Relation Lines
        state.perpBisectors.forEach(pb => {
            const mid = calcMid(pb.p1, pb.p2); const dx = pb.p2.x - pb.p1.x; const dy = pb.p2.y - pb.p1.y;
            pb.p1_res.x = mid.x - dy; pb.p1_res.y = mid.y + dx; pb.p2_res.x = mid.x + dy; pb.p2_res.y = mid.y - dx;
        });
        state.angleBisectors.forEach(ab => {
            const ang1 = Math.atan2(ab.p1.y - ab.vertex.y, ab.p1.x - ab.vertex.x);
            const ang2 = Math.atan2(ab.p2.y - ab.vertex.y, ab.p2.x - ab.vertex.x);
            const bisectAng = (ang1 + ang2) / 2; const r = 100;
            ab.res.x = ab.vertex.x + r * Math.cos(bisectAng); ab.res.y = ab.vertex.y + r * Math.sin(bisectAng);
        });
        state.perpendiculars.forEach(perp => {
            const dx = perp.lp2.x - perp.lp1.x; const dy = perp.lp2.y - perp.lp1.y;
            perp.res.x = perp.through.x - dy; perp.res.y = perp.through.y + dx;
        });
        state.parallels.forEach(par => {
            const dx = par.lp2.x - par.lp1.x; const dy = par.lp2.y - par.lp1.y;
            par.res.x = par.through.x + dx; par.res.y = par.through.y + dy;
        });
    }

    function draw() {
        updateDependentPoints();
        ctx.clearRect(0, 0, W, H);
        
        // Grid
        if (showGrid) {
            ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 1; ctx.setLineDash([]);
            for (let i = 0; i <= W; i += SCALE) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, H); ctx.stroke(); }
            for (let i = 0; i <= H; i += SCALE) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(W, i); ctx.stroke(); }
            ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(W / 2, 0); ctx.lineTo(W / 2, H); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, H / 2); ctx.lineTo(W, H / 2); ctx.stroke();
        }

        const color = document.getElementById('color').value;
        const thickness = parseFloat(document.getElementById('thickness').value) || 2;
        const lineStyle = document.getElementById('line-style').value;
        const fillColor = document.getElementById('fill-color').value;
        const opacity = parseFloat(document.getElementById('opacity').value) / 100;

        // Fills & Clips
        state.clips.forEach(clip => {
            ctx.save(); ctx.beginPath(); ctx.moveTo(clip.points[0].x, clip.points[0].y);
            for (let i = 1; i < clip.points.length; i++) ctx.lineTo(clip.points[i].x, clip.points[i].y);
            ctx.closePath(); ctx.clip();
        });
        state.fills.forEach(fill => {
            ctx.fillStyle = fill.color || fillColor; ctx.globalAlpha = fill.opacity || opacity;
            ctx.beginPath(); ctx.moveTo(fill.points[0].x, fill.points[0].y);
            for (let i = 1; i < fill.points.length; i++) ctx.lineTo(fill.points[i].x, fill.points[i].y);
            ctx.closePath(); ctx.fill(); ctx.globalAlpha = 1;
        });
        state.fillCircles.forEach(fc => {
            ctx.fillStyle = fc.color || fillColor; ctx.globalAlpha = fc.opacity || opacity;
            const r = fc.radius || Math.hypot(fc.pointOnCircle.x - fc.center.x, fc.pointOnCircle.y - fc.center.y);
            ctx.beginPath(); ctx.arc(fc.center.x, fc.center.y, r, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1;
        });

        // Lines & Shapes
        ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = thickness;
        if (lineStyle === 'dashed') ctx.setLineDash([10, 8]); else if (lineStyle === 'dotted') ctx.setLineDash([3, 6]); else ctx.setLineDash([]);
        
        state.segments.forEach(seg => { ctx.beginPath(); ctx.moveTo(seg.p1.x, seg.p1.y); ctx.lineTo(seg.p2.x, seg.p2.y); ctx.stroke(); });
        state.tangents.forEach(t => { 
             ctx.beginPath(); ctx.moveTo(t.pt.x, t.pt.y); ctx.lineTo(t.t1.x, t.t1.y); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(t.pt.x, t.pt.y); ctx.lineTo(t.t2.x, t.t2.y); ctx.stroke();
        });
        
        state.lines.forEach(line => {
            const dx = line.p2.x - line.p1.x, dy = line.p2.y - line.p1.y; const len = Math.hypot(dx, dy); if(len < 1e-6) return;
            const ux = dx / len, uy = dy / len; const ext = 2000;
            ctx.beginPath(); ctx.moveTo(line.p1.x - ext * ux, line.p1.y - ext * uy); ctx.lineTo(line.p1.x + ext * ux, line.p1.y + ext * uy); ctx.stroke();
        });
        state.circles.forEach(circ => {
            const r = Math.hypot(circ.p2.x - circ.p1.x, circ.p2.y - circ.p1.y);
            ctx.beginPath(); ctx.arc(circ.p1.x, circ.p1.y, r, 0, Math.PI * 2); ctx.stroke();
        });
        state.circleRadii.forEach(circ => { ctx.beginPath(); ctx.arc(circ.center.x, circ.center.y, circ.radius, 0, Math.PI * 2); ctx.stroke(); });
        state.arcs.forEach(arc => {
            const r = Math.hypot(arc.p2.x - arc.p1.x, arc.p2.y - arc.p1.y);
            const startAngle = Math.atan2(arc.p2.y - arc.p1.y, arc.p2.x - arc.p1.x);
            const endAngle = Math.atan2(arc.p3.y - arc.p1.y, arc.p3.x - arc.p1.x);
            ctx.beginPath(); ctx.arc(arc.p1.x, arc.p1.y, r, startAngle, endAngle); ctx.stroke();
        });
        state.polygons.forEach(poly => {
            if (poly.points.length < 2) return;
            ctx.beginPath(); ctx.moveTo(poly.points[0].x, poly.points[0].y);
            for (let i = 1; i < poly.points.length; i++) ctx.lineTo(poly.points[i].x, poly.points[i].y);
            ctx.closePath(); ctx.stroke();
        });

        // --- PREVIEW LAYER ---
        if (temp.length > 0) {
            ctx.save(); ctx.strokeStyle = '#9ca3af'; ctx.setLineDash([5, 5]); ctx.lineWidth = 1.5;
            const p1 = temp[temp.length - 1];
            
            if (['segment','line','perp-bisector','sym-line','mark-segment'].includes(tool)) {
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(mousePos.x, mousePos.y); ctx.stroke();
                if(tool === 'line') {
                    const dx = mousePos.x - p1.x, dy = mousePos.y - p1.y; const len = Math.hypot(dx, dy);
                    if(len > 1) { const ux = dx/len, uy = dy/len; ctx.beginPath(); ctx.moveTo(p1.x - 1000*ux, p1.y - 1000*uy); ctx.lineTo(p1.x + 1000*ux, p1.y + 1000*uy); ctx.stroke(); }
                }
            } else if (tool === 'circle') {
                const r = Math.hypot(mousePos.x - p1.x, mousePos.y - p1.y);
                ctx.beginPath(); ctx.arc(p1.x, p1.y, r, 0, Math.PI * 2); ctx.stroke();
            } else if (tool === 'polygon' || tool === 'fill-polygon') {
                 ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(mousePos.x, mousePos.y); ctx.stroke();
                 if(temp.length > 1) { ctx.setLineDash([2, 8]); ctx.beginPath(); ctx.moveTo(mousePos.x, mousePos.y); ctx.lineTo(temp[0].x, temp[0].y); ctx.stroke(); }
            } else if (tool === 'tangent' && temp.length === 2) {
                 // Preview tangent circle
                 const r = Math.hypot(mousePos.x - temp[1].x, mousePos.y - temp[1].y);
                 ctx.beginPath(); ctx.arc(temp[1].x, temp[1].y, r, 0, Math.PI*2); ctx.stroke();
            }
            ctx.restore();
        }

        // --- HOVER EFFECT ---
        const hoverP = findPoint(mousePos.x, mousePos.y);
        if (hoverP && !moving) {
            ctx.save(); ctx.strokeStyle = '#2563eb'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(hoverP.x, hoverP.y, 8, 0, Math.PI * 2); ctx.stroke(); ctx.restore();
        }

        // Marks
        ctx.setLineDash([]);
        state.markAngles.forEach(mark => {
            const r = 20; const ang1 = Math.atan2(mark.p1.y - mark.vertex.y, mark.p1.x - mark.vertex.x); const ang2 = Math.atan2(mark.p2.y - mark.vertex.y, mark.p2.x - mark.vertex.x);
            ctx.beginPath(); ctx.arc(mark.vertex.x, mark.vertex.y, r, ang1, ang2); ctx.stroke();
        });
        state.markRights.forEach(mark => {
            const size = 15;
            const dx1 = mark.p1.x - mark.vertex.x, dy1 = mark.p1.y - mark.vertex.y; const dx2 = mark.p2.x - mark.vertex.x, dy2 = mark.p2.y - mark.vertex.y;
            const len1 = Math.hypot(dx1, dy1), len2 = Math.hypot(dx2, dy2); const ux1 = dx1 / len1, uy1 = dy1 / len1, ux2 = dx2 / len2, uy2 = dy2 / len2;
            const corner = { x: mark.vertex.x + size * ux1 + size * ux2, y: mark.vertex.y + size * uy1 + size * uy2 };
            ctx.beginPath(); ctx.moveTo(mark.vertex.x + size * ux1, mark.vertex.y + size * uy1); ctx.lineTo(corner.x, corner.y); ctx.lineTo(mark.vertex.x + size * ux2, mark.vertex.y + size * uy2); ctx.stroke();
        });
        state.markSegments.forEach(mark => {
            const mx = (mark.p1.x + mark.p2.x) / 2, my = (mark.p1.y + mark.p2.y) / 2; 
            const dx = mark.p2.x - mark.p1.x, dy = mark.p2.y - mark.p1.y; 
            const len = Math.hypot(dx, dy);
            const ux = -dy / len, uy = dx / len; 
            const type = mark.mark || (mark.count == 2 ? '||' : (mark.count == 3 ? '|||' : '|')); // Fallback for old data
            
            ctx.save();
            ctx.lineWidth = 1.5;
            
            if (type.includes('|')) {
                const count = type.length;
                const size = 8, gap = 4;
                for (let i = 0; i < count; i++) {
                    const offset = (i - (count - 1) / 2) * gap;
                    ctx.beginPath(); 
                    ctx.moveTo(mx + offset * uy - size * ux, my - offset * ux - size * uy); 
                    ctx.lineTo(mx + offset * uy + size * ux, my - offset * ux + size * uy); 
                    ctx.stroke();
                }
            } else if (type === 'x') {
                const size = 6;
                const udx = dx/len, udy = dy/len;
                // Rotate 45 deg
                const r45 = Math.PI/4;
                const c = Math.cos(r45), s = Math.sin(r45);
                // V1 = u * rot(+45), V2 = u * rot(-45)
                // Draw X relative to segment
                ctx.beginPath();
                ctx.moveTo(mx - size, my - size); ctx.lineTo(mx + size, my + size);
                ctx.moveTo(mx - size, my + size); ctx.lineTo(mx + size, my - size);
                ctx.stroke();
            } else if (type === 'o') {
                ctx.beginPath(); ctx.arc(mx, my, 4, 0, Math.PI*2); ctx.stroke();
            } else if (type === 'z' || type === 's') {
                ctx.font = '14px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText(type, mx, my);
            }
            ctx.restore();
        });

        // Points & Labels
        state.points.forEach(p => {
            if(p.generated && tool !== 'move') { ctx.fillStyle = '#dc2626'; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI * 2); ctx.fill(); }
            else { ctx.fillStyle = '#dc2626'; ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI * 2); ctx.fill(); }
            ctx.fillStyle = '#000'; ctx.font = 'bold 14px Arial'; ctx.fillText(p.name, p.x + 8, p.y - 8);
        });
        state.labels.forEach(lbl => { ctx.fillStyle = '#000'; ctx.font = '14px Arial'; ctx.fillText(lbl.text, lbl.point.x + 10, lbl.point.y - 10); });
        state.labelSegments.forEach(lbl => { const mx = (lbl.p1.x + lbl.p2.x) / 2, my = (lbl.p1.y + lbl.p2.y) / 2; ctx.fillStyle = '#000'; ctx.font = '13px Arial'; ctx.fillText(lbl.text, mx + 5, my - 5); });
        state.labelAngles.forEach(lbl => {
            const r = 30; const ang1 = Math.atan2(lbl.p1.y - lbl.vertex.y, lbl.p1.x - lbl.vertex.x); const ang2 = Math.atan2(lbl.p2.y - lbl.vertex.y, lbl.p2.x - lbl.vertex.x); const midAng = (ang1 + ang2) / 2;
            const lx = lbl.vertex.x + r * Math.cos(midAng); const ly = lbl.vertex.y + r * Math.sin(midAng);
            ctx.fillStyle = '#000'; ctx.font = '13px Arial'; ctx.fillText(lbl.text, lx, ly);
        });

        if (temp.length > 0) { ctx.fillStyle = '#3b82f6'; temp.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI * 2); ctx.fill(); }); }
        if (state.clips.length > 0) ctx.restore();
        generateCode();
    }

    function generateCode() {
        let latex = '\\begin{tikzpicture}\n';
        latex += '  % ƒê·ªãnh nghƒ©a ƒëi·ªÉm\n';
        state.points.forEach(p => { if (!p.generated) latex += `  \\tkzDefPoint${toTikZ(p.x, p.y)}{${p.name}}\n`; });
        
        if (state.midpoints.length) latex += '  % Trung ƒëi·ªÉm\n';
        state.midpoints.forEach(m => latex += `  \\tkzDefMidPoint(${m.p1.name},${m.p2.name})\\tkzGetPoint{${m.result.name}}\n`);
        if (state.circumcenters.length) latex += '  % T√¢m ngo·∫°i ti·∫øp\n';
        state.circumcenters.forEach(cc => latex += `  \\tkzDefCircumCenter(${cc.p1.name},${cc.p2.name},${cc.p3.name})\\tkzGetPoint{${cc.result.name}}\n`);
        if (state.incenters.length) latex += '  % T√¢m n·ªôi ti·∫øp\n';
        state.incenters.forEach(ic => latex += `  \\tkzDefInCenter(${ic.p1.name},${ic.p2.name},${ic.p3.name})\\tkzGetPoint{${ic.result.name}}\n`);
        if (state.orthocenters.length) latex += '  % Tr·ª±c t√¢m\n';
        state.orthocenters.forEach(oc => latex += `  \\tkzDefOrthoCenter(${oc.p1.name},${oc.p2.name},${oc.p3.name})\\tkzGetPoint{${oc.result.name}}\n`);
        if (state.centroids.length) latex += '  % Tr·ªçng t√¢m\n';
        state.centroids.forEach(c => latex += `  \\tkzDefBarycentricPoint(${c.p1.name}=1,${c.p2.name}=1,${c.p3.name}=1)\\tkzGetPoint{${c.result.name}}\n`);
        if (state.intersections.length) latex += '  % Giao ƒëi·ªÉm (Line-Line/Line-Circle)\n';
        state.intersections.forEach(inter => {
            if (inter.type === 'll') latex += `  \\tkzInterLL(${inter.l1p1.name},${inter.l1p2.name})(${inter.l2p1.name},${inter.l2p2.name})\\tkzGetPoint{${inter.result.name}}\n`;
            else if (inter.type === 'cl') latex += `  \\tkzInterLC(${inter.lp1.name},${inter.lp2.name})(${inter.center.name},${inter.pointOnCircle.name})\\tkzGetPoints{${inter.result1.name}}{${inter.result2.name}}\n`;
        });
        
        if (state.intersectionsCC.length) latex += '  % Giao 2 ƒë∆∞·ªùng tr√≤n\n';
        state.intersectionsCC.forEach(cc => latex += `  \\tkzInterCC(${cc.c1.name},${cc.c1r.name})(${cc.c2.name},${cc.c2r.name})\\tkzGetPoints{${cc.res1.name}}{${cc.res2.name}}\n`);

        if (state.tangents.length) latex += '  % Ti·∫øp tuy·∫øn\n';
        state.tangents.forEach(t => {
            latex += `  \\tkzDefLine[tangent from=${t.pt.name}](${t.c.name},${t.cr.name})\\tkzGetPoints{${t.t1.name}}{${t.t2.name}}\n`;
            latex += `  \\tkzDrawSegments(${t.pt.name},${t.t1.name} ${t.pt.name},${t.t2.name})\n`;
        });

        if (state.symPoints.length) latex += '  % ƒê·ªëi x·ª©ng t√¢m\n';
        state.symPoints.forEach(s => latex += `  \\tkzDefPointBy[symmetry=center ${s.center.name}](${s.pt.name})\\tkzGetPoint{${s.res.name}}\n`);
        
        if (state.symLines.length) latex += '  % ƒê·ªëi x·ª©ng tr·ª•c\n';
        state.symLines.forEach(s => latex += `  \\tkzDefPointBy[reflection=over ${s.lp1.name}--${s.lp2.name}](${s.pt.name})\\tkzGetPoint{${s.res.name}}\n`);
        
        if (state.translations.length) latex += '  % T·ªãnh ti·∫øn\n';
        state.translations.forEach(tr => latex += `  \\tkzDefPointBy[translation=from ${tr.v1.name} to ${tr.v2.name}](${tr.pt.name})\\tkzGetPoint{${tr.res.name}}\n`);

        if (state.projections.length) latex += '  % H√¨nh chi·∫øu\n';
        state.projections.forEach(proj => latex += `  \\tkzDefPointBy[projection=onto ${proj.lp1.name}--${proj.lp2.name}](${proj.point.name})\\tkzGetPoint{${proj.result.name}}\n`);

        latex += '\n  % C√°c ƒë∆∞·ªùng ƒë·∫∑c bi·ªát\n';
        state.perpBisectors.forEach(pb => { latex += `  \\tkzDefLine[mediator](${pb.p1.name},${pb.p2.name})\\tkzGetPoints{${pb.p1_res.name}}{${pb.p2_res.name}}\n  \\tkzDrawLine(${pb.p1_res.name},${pb.p2_res.name})\n`; });
        state.angleBisectors.forEach(ab => { latex += `  \\tkzDefLine[bisector](${ab.p1.name},${ab.vertex.name},${ab.p2.name})\\tkzGetPoint{${ab.res.name}}\n  \\tkzDrawLine(${ab.vertex.name},${ab.res.name})\n`; });
        state.perpendiculars.forEach(perp => { latex += `  \\tkzDefLine[perpendicular=through ${perp.through.name}](${perp.lp1.name},${perp.lp2.name})\\tkzGetPoint{${perp.res.name}}\n  \\tkzDrawLine(${perp.through.name},${perp.res.name})\n`; });
        state.parallels.forEach(par => { latex += `  \\tkzDefLine[parallel=through ${par.through.name}](${par.lp1.name},${par.lp2.name})\\tkzGetPoint{${par.res.name}}\n  \\tkzDrawLine(${par.through.name},${par.res.name})\n`; });

        if (state.fills.length || state.fillCircles.length) {
            latex += '  % T√¥ m√†u\n';
            state.fills.forEach(fill => latex += `  \\tkzFillPolygon[fill=blue!30,opacity=${fill.opacity||0.3}](${fill.points.map(p=>p.name).join(',')})\n`);
            state.fillCircles.forEach(fc => latex += `  \\tkzFillCircle[fill=blue!30,opacity=${fc.opacity||0.3}](${fc.center.name},${fc.pointOnCircle.name})\n`);
        }
        if (state.clips.length) state.clips.forEach(clip => latex += `  \\tkzClipPolygon(${clip.points.map(p=>p.name).join(',')})\n`);

        latex += '  % V·∫Ω h√¨nh\n';
        state.segments.forEach(seg => latex += `  \\tkzDrawSegment(${seg.p1.name},${seg.p2.name})\n`);
        state.medians.forEach(med => latex += `  \\tkzDrawSegment(${med.p1.name},${med.result.name})\n`);
        state.altitudes.forEach(alt => latex += `  \\tkzDrawSegment(${alt.p1.name},${alt.result.name})\n`);
        state.lines.forEach(line => { if(!line.isGenerated) latex += `  \\tkzDrawLine(${line.p1.name},${line.p2.name})\n`; });
        state.circles.forEach(circ => latex += `  \\tkzDrawCircle(${circ.p1.name},${circ.p2.name})\n`);
        state.circleRadii.forEach(circ => latex += `  \\tkzDrawCircle[R](${circ.center.name},${(circ.radius/SCALE).toFixed(2)}cm)\n`);
        state.arcs.forEach(arc => latex += `  \\tkzDrawArc(${arc.p1.name},${arc.p2.name})(${arc.p3.name})\n`);
        state.polygons.forEach(poly => latex += `  \\tkzDrawPolygon(${poly.points.map(p=>p.name).join(',')})\n`);

        if (state.markAngles.length || state.markRights.length || state.markSegments.length) {
            latex += '  % ƒê√°nh d·∫•u\n';
            state.markRights.forEach(mark => latex += `  \\tkzMarkRightAngle(${mark.p1.name},${mark.vertex.name},${mark.p2.name})\n`);
            state.markAngles.forEach(mark => latex += `  \\tkzMarkAngle[size=0.6](${mark.p1.name},${mark.vertex.name},${mark.p2.name})\n`);
            state.markSegments.forEach(mark => { 
                let sym = mark.mark || (mark.count===2?'||':(mark.count===3?'|||':'|')); 
                latex += `  \\tkzMarkSegment[mark=${sym}](${mark.p1.name},${mark.p2.name})\n`; 
            });
        }
        latex += '  % Nh√£n\n';
        state.labels.forEach(lbl => latex += `  \\tkzLabelPoint[above right](${lbl.point.name}){${lbl.text}$}\n`);
        state.labelSegments.forEach(lbl => latex += `  \\tkzLabelSegment[above](${lbl.p1.name},${lbl.p2.name}){${lbl.text}$}\n`);
        state.labelAngles.forEach(lbl => latex += `  \\tkzLabelAngle[pos=1](${lbl.p1.name},${lbl.vertex.name},${lbl.p2.name}){${lbl.text}$}\n`);
        
        if (state.points.length > 0) { const pointNames = state.points.map(p => p.name).join(','); latex += `  \\tkzDrawPoints(${pointNames})\n  \\tkzLabelPoints(${pointNames})\n`; }
        latex += '\\end{tikzpicture}';
        codeEl.value = latex;
    }

    // --- EVENT HANDLING ---
    function handleStart(e) {
        if(e.type === 'touchstart') e.preventDefault();
        const pos = getPointerPos(e);
        const mx = pos.x; const my = pos.y;
        mousePos = pos;

        if (tool === 'point-on-circle') {handlePointOnCircle({ x: mx, y: my });return; }
        if (tool === 'move') { moving = findPoint(mx, my); return; }
        if (tool === 'delete') {
            const p = findPoint(mx, my);
            if (p) {
                if(p.generated) { showStatus('Kh√¥ng th·ªÉ x√≥a tr·ª±c ti·∫øp ƒëi·ªÉm ph·ª• thu·ªôc!'); return; }
                state.points = state.points.filter(pt => pt !== p);
                state.segments = state.segments.filter(s => s.p1 !== p && s.p2 !== p);
                state.lines = state.lines.filter(l => l.p1 !== p && l.p2 !== p);
                state.circles = state.circles.filter(c => c.p1 !== p && c.p2 !== p);
                state.polygons = state.polygons.filter(poly => !poly.points.includes(p));
                // Clean up references
                state.midpoints = state.midpoints.filter(i => i.p1 !== p && i.p2 !== p);
                // Also clean new structures if needed (simplified for brevity)
                save(); draw(); showStatus('ƒê√£ x√≥a ƒëi·ªÉm');
            }
            return;
        }

        let p = findPoint(mx, my);
        if (!p && tool === 'point') {
            const snapped = snapPoint(mx, my);
            p = { x: snapped.x, y: snapped.y, name: newName() };
            state.points.push(p); save(); draw(); showStatus(`ƒê√£ th√™m ƒëi·ªÉm ${p.name}`); return;
        }
        
        // Auto-create point if clicking empty space for most tools
        if (!p && ['segment','line','circle','polygon','triangle','tangent','sym-point','sym-line','translation','mark-segment'].includes(tool)) {
             const snapped = snapPoint(mx, my);
             p = { x: snapped.x, y: snapped.y, name: newName() };
             state.points.push(p);
        }

        if (p) {
            temp.push(p);
            
            // Logic c√°c c√¥ng c·ª•
            if (tool === 'midpoint' && temp.length === 2) { const mid = calcMid(temp[0], temp[1]); const newP = { x: mid.x, y: mid.y, name: newName(), generated: true }; state.points.push(newP); state.midpoints.push({p1: temp[0], p2: temp[1], result: newP}); temp = []; save(); draw(); showStatus('ƒê√£ th√™m trung ƒëi·ªÉm'); }
            if (tool === 'centroid' && temp.length === 3) { const res = calcCentroid(temp[0], temp[1], temp[2]); const newP = { x: res.x, y: res.y, name: newName(), generated: true }; state.points.push(newP); state.centroids.push({p1: temp[0], p2: temp[1], p3: temp[2], result: newP}); temp = []; save(); draw(); showStatus('ƒê√£ th√™m tr·ªçng t√¢m'); }
            if (tool === 'circumcenter' && temp.length === 3) { const res = calcCircumcenter(temp[0], temp[1], temp[2]); if(res){const newP = { x: res.x, y: res.y, name: newName(), generated: true }; state.points.push(newP); state.circumcenters.push({p1: temp[0], p2: temp[1], p3: temp[2], result: newP});} temp = []; save(); draw(); showStatus('ƒê√£ th√™m t√¢m ngo·∫°i ti·∫øp'); }
            if (tool === 'incenter' && temp.length === 3) { const res = calcIncenter(temp[0], temp[1], temp[2]); const newP = { x: res.x, y: res.y, name: newName(), generated: true }; state.points.push(newP); state.incenters.push({p1: temp[0], p2: temp[1], p3: temp[2], result: newP}); temp = []; save(); draw(); showStatus('ƒê√£ th√™m t√¢m n·ªôi ti·∫øp'); }
            if (tool === 'orthocenter' && temp.length === 3) { const res = calcOrthocenter(temp[0], temp[1], temp[2]); if(res){const newP = { x: res.x, y: res.y, name: newName(), generated: true }; state.points.push(newP); state.orthocenters.push({p1: temp[0], p2: temp[1], p3: temp[2], result: newP});} temp = []; save(); draw(); showStatus('ƒê√£ th√™m tr·ª±c t√¢m'); }

            if (tool === 'segment' && temp.length === 2) { state.segments.push({p1: temp[0], p2: temp[1]}); temp=[]; save(); draw(); showStatus('ƒê√£ v·∫Ω ƒëo·∫°n th·∫≥ng'); }
            if (tool === 'line' && temp.length === 2) { state.lines.push({p1: temp[0], p2: temp[1]}); temp=[]; save(); draw(); showStatus('ƒê√£ v·∫Ω ƒë∆∞·ªùng th·∫≥ng'); }
            if (tool === 'circle' && temp.length === 2) { state.circles.push({p1: temp[0], p2: temp[1]}); temp=[]; save(); draw(); showStatus('ƒê√£ v·∫Ω ƒë∆∞·ªùng tr√≤n'); }
            if (tool === 'circle-radius' && temp.length === 1) { 
                const radius = parseFloat(prompt('Nh·∫≠p b√°n k√≠nh (cm):', '3'));
                if(radius) state.circleRadii.push({center: temp[0], radius: radius*SCALE}); 
                temp=[]; save(); draw(); 
            }
            if (tool === 'polygon' && temp.length > 2 && temp[0] === p) {
                state.polygons.push({points: [...temp].slice(0,-1)}); temp=[]; save(); draw(); showStatus('ƒê√£ v·∫Ω ƒëa gi√°c');
            } else if (tool === 'polygon' && temp.length >= 2 && p === temp[0]) {
                 state.polygons.push({points: [...temp].slice(0,-1)}); temp=[]; save(); draw(); showStatus('ƒê√£ v·∫Ω ƒëa gi√°c');
            }
            if (tool === 'arc' && temp.length === 3) { state.arcs.push({p1: temp[0], p2: temp[1], p3: temp[2]}); temp=[]; save(); draw(); showStatus('ƒê√£ v·∫Ω cung'); }

            if (tool === 'perp-bisector' && temp.length === 2) { const r1={x:0,y:0,name:newName(),generated:true}; const r2={x:0,y:0,name:newName(),generated:true}; state.points.push(r1,r2); state.perpBisectors.push({p1:temp[0], p2:temp[1], p1_res:r1, p2_res:r2}); temp=[]; save(); draw(); }
            if (tool === 'median' && temp.length === 2) { const r={x:0,y:0,name:newName(),generated:true}; state.points.push(r); state.midpoints.push({p1:temp[0], p2:temp[1], result:r}); state.medians.push({p1:temp[0], result:r}); temp=[]; save(); draw(); } // Note: Logic simplified
            if (tool === 'median' && temp.length === 3) { const r={x:0,y:0,name:newName(),generated:true}; state.points.push(r); state.midpoints.push({p1:temp[1], p2:temp[2], result:r}); state.medians.push({p1:temp[0], result:r}); temp=[]; save(); draw(); }
            if (tool === 'altitude' && temp.length === 3) { const r={x:0,y:0,name:newName(),generated:true}; state.points.push(r); state.projections.push({point:temp[0], lp1:temp[1], lp2:temp[2], result:r}); state.altitudes.push({p1:temp[0], result:r}); temp=[]; save(); draw(); }
            if (tool === 'angle-bisector' && temp.length === 3) { const r={x:0,y:0,name:newName(),generated:true}; state.points.push(r); state.angleBisectors.push({p1:temp[0], vertex:temp[1], p2:temp[2], res:r}); temp=[]; save(); draw(); }
            if (tool === 'perpendicular' && temp.length === 3) { const r={x:0,y:0,name:newName(),generated:true}; state.points.push(r); state.perpendiculars.push({through:temp[0], lp1:temp[1], lp2:temp[2], res:r}); temp=[]; save(); draw(); }
            if (tool === 'parallel' && temp.length === 3) { const r={x:0,y:0,name:newName(),generated:true}; state.points.push(r); state.parallels.push({through:temp[0], lp1:temp[1], lp2:temp[2], res:r}); temp=[]; save(); draw(); }
            
            if (tool === 'intersection-ll' && temp.length === 4) { const r={x:0,y:0,name:newName(),generated:true}; state.points.push(r); state.intersections.push({type:'ll', l1p1:temp[0], l1p2:temp[1], l2p1:temp[2], l2p2:temp[3], result:r}); temp=[]; save(); draw(); }
            
            // --- NEW TOOLS ---
            if (tool === 'tangent' && temp.length === 3) {
                 // 1: Point, 2: Center, 3: Point on Circle
                 const t1 = {x:0,y:0,name:newName(),generated:true};
                 const t2 = {x:0,y:0,name:newName(),generated:true};
                 state.points.push(t1, t2);
                 state.tangents.push({pt: temp[0], c: temp[1], cr: temp[2], t1: t1, t2: t2});
                 temp = []; save(); draw(); showStatus('ƒê√£ v·∫Ω ti·∫øp tuy·∫øn');
            }
            if (tool === 'inter-cc' && temp.length === 4) {
                 // 1,2: Circle 1; 3,4: Circle 2
                 const r1 = {x:0,y:0,name:newName(),generated:true};
                 const r2 = {x:0,y:0,name:newName(),generated:true};
                 state.points.push(r1, r2);
                 state.intersectionsCC.push({c1: temp[0], c1r: temp[1], c2: temp[2], c2r: temp[3], res1: r1, res2: r2});
                 temp = []; save(); draw(); showStatus('ƒê√£ t√¨m giao 2 ƒë∆∞·ªùng tr√≤n');
            }
            if (tool === 'sym-point' && temp.length === 2) {
                 // 1: Center, 2: Point
                 const r = {x:0,y:0,name:newName(),generated:true};
                 state.points.push(r);
                 state.symPoints.push({center: temp[0], pt: temp[1], res: r});
                 temp = []; save(); draw(); showStatus('ƒê√£ l·∫•y ƒë·ªëi x·ª©ng t√¢m');
            }
            if (tool === 'sym-line' && temp.length === 3) {
                 // 1,2: Line; 3: Point
                 const r = {x:0,y:0,name:newName(),generated:true};
                 state.points.push(r);
                 state.symLines.push({lp1: temp[0], lp2: temp[1], pt: temp[2], res: r});
                 temp = []; save(); draw(); showStatus('ƒê√£ l·∫•y ƒë·ªëi x·ª©ng tr·ª•c');
            }
            if (tool === 'translation' && temp.length === 3) {
                 // 1: From, 2: To (Vector), 3: Point to move
                 const r = {x:0,y:0,name:newName(),generated:true};
                 state.points.push(r);
                 state.translations.push({v1: temp[0], v2: temp[1], pt: temp[2], res: r});
                 temp = []; save(); draw(); showStatus('ƒê√£ t·ªãnh ti·∫øn ƒëi·ªÉm');
            }

            if (tool === 'projection' && temp.length === 3) { const r={x:0,y:0,name:newName(),generated:true}; state.points.push(r); state.projections.push({point:temp[0], lp1:temp[1], lp2:temp[2], result:r}); temp=[]; save(); draw(); }
            if (tool === 'fill-polygon' && temp.length >= 3 && (e.shiftKey || temp.length>=10)) { state.fills.push({points: [...temp], color: document.getElementById('fill-color').value, opacity: parseFloat(document.getElementById('opacity').value)/100}); temp=[]; save(); draw(); showStatus('ƒê√£ t√¥ ƒëa gi√°c'); }
            if (tool === 'mark-angle' && temp.length === 3) { state.markAngles.push({p1:temp[0], vertex:temp[1], p2:temp[2]}); temp=[]; save(); draw(); }
            if (tool === 'mark-right' && temp.length === 3) { state.markRights.push({p1:temp[0], vertex:temp[1], p2:temp[2]}); temp=[]; save(); draw(); }
            // NEW: Mark Segment Logic
            if (tool === 'mark-segment' && temp.length === 2) {
                 const markStyle = document.getElementById('mark-style').value;
                 state.markSegments.push({p1:temp[0], p2:temp[1], mark:markStyle});
                 temp=[]; save(); draw(); showStatus('ƒê√£ ƒë√°nh d·∫•u ƒëo·∫°n');
            }

            if (tool === 'label' && temp.length === 1) { 
                const txt = prompt('T√™n ƒëi·ªÉm:', temp[0].name); 
                if(txt) { temp[0].name = txt; save(); draw(); }
                temp=[]; 
            }
            
            draw(); // Redraw to show selection
        }
    }

    function handleMove(e) {
        if(e.type === 'touchmove') e.preventDefault();
        mousePos = getPointerPos(e);
        
        if (moving) { 
            if(moving.generated) return;
            const snapped = snapPoint(mousePos.x, mousePos.y);
            moving.x = snapped.x; moving.y = snapped.y; 
            draw(); 
        } else {
            // Always redraw to show preview lines/hover effects
            draw();
        }
    }

    function handleEnd(e) {
        if(e.type === 'touchend') e.preventDefault();
        if (moving) { save(); moving = null; }
    }

    // G√°n Event Listeners
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('touchstart', handleStart, {passive: false});
    canvas.addEventListener('touchmove', handleMove, {passive: false});
    canvas.addEventListener('touchend', handleEnd, {passive: false});

    document.addEventListener('keydown', e => { if(e.key==='Escape'){temp=[]; moving=null; draw();} if(e.ctrlKey && e.key==='z'){e.preventDefault(); document.getElementById('geo-undo').click();} if(e.ctrlKey && e.key==='y'){e.preventDefault(); document.getElementById('geo-redo').click();} });

    // UI Bindings
    document.querySelectorAll('#geo-toolbar button').forEach(btn => {
        btn.addEventListener('click', () => {
            if (btn.id.startsWith('tool-')) {
                document.querySelectorAll('#geo-toolbar button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active'); tool = btn.id.replace('tool-', ''); temp = []; showStatus(`C√¥ng c·ª•: ${btn.textContent}`); draw();
            }
        });
    });
    
    document.getElementById('geo-undo').onclick = () => { if(historyIndex>0){historyIndex--; state=JSON.parse(JSON.stringify(history[historyIndex])); draw(); document.getElementById('geo-redo').disabled=false; if(historyIndex===0)document.getElementById('geo-undo').disabled=true;} };
    document.getElementById('geo-redo').onclick = () => { if(historyIndex<history.length-1){historyIndex++; state=JSON.parse(JSON.stringify(history[historyIndex])); draw(); document.getElementById('geo-undo').disabled=false; if(historyIndex===history.length-1)document.getElementById('geo-redo').disabled=true;} };
    document.getElementById('geo-copy').onclick = () => { codeEl.select(); document.execCommand('copy'); showStatus('ƒê√£ sao ch√©p!'); };
    document.getElementById('geo-export').onclick = () => { const link = document.createElement('a'); link.download = 'hinh-tkz.png'; link.href = canvas.toDataURL(); link.click(); };
    document.getElementById('toggle-grid').onclick = function() { showGrid=!showGrid; this.textContent=showGrid?'üî≤ T·∫Øt l∆∞·ªõi':'üî≤ B·∫≠t l∆∞·ªõi'; draw(); };
    document.getElementById('toggle-snap').onclick = function() { snapToGrid=!snapToGrid; this.textContent=snapToGrid?'üß≤ T·∫Øt snap':'üß≤ B·∫≠t snap'; };
    document.getElementById('clear').onclick = () => { if(confirm('X√≥a h·∫øt?')) { location.reload(); } };
    
    ['color','thickness','fill-color','opacity','line-style'].forEach(id => document.getElementById(id).addEventListener(id==='opacity'?'input':'change', draw));

    window.geo_init = function() { window.geo_resize(); };
})();
</script>
<script>
function openGuide(){
    const modal = new bootstrap.Modal(document.getElementById('guideModal'));
    modal.show();
}
</script>
<script>
/* ====== TOOL: POINT ON CIRCLE ====== */
let pointOnCircleStep = 0;
let selectedCircle = null;

document.getElementById("tool-point-on-circle").onclick = () => {
    setActiveTool("point-on-circle");
    pointOnCircleStep = 0;
    selectedCircle = null;
    showStatus("Ch·ªçn ƒë∆∞·ªùng tr√≤n");
};
</script>
<script>
function handlePointOnCircle(pos) {
    if (pointOnCircleStep === 0) {
        selectedCircle = findNearestCircle(pos);
        if (!selectedCircle) {
            showStatus("Ch∆∞a ch·ªçn ƒë∆∞·ª£c ƒë∆∞·ªùng tr√≤n");
            return;
        }
        pointOnCircleStep = 1;
        showStatus("Ch·∫°m l√™n ƒë∆∞·ªùng tr√≤n ƒë·ªÉ t·∫°o ƒëi·ªÉm");
        return;
    }

    if (pointOnCircleStep === 1) {
        const angle = Math.atan2(
            pos.y - selectedCircle.center.y,
            pos.x - selectedCircle.center.x
        );

        const x = selectedCircle.center.x + selectedCircle.r * Math.cos(angle);
        const y = selectedCircle.center.y + selectedCircle.r * Math.sin(angle);

        const name = generatePointName();
        points.push({ name, x, y });

        latexCode.push(
            `% ƒêi·ªÉm ${name} n·∫±m tr√™n ƒë∆∞·ªùng tr√≤n`,
            `\\tkzDefPoint(${x.toFixed(2)},${y.toFixed(2)}){${name}}`
        );

        redraw();
        updateLatex();
        showStatus(`ƒê√£ t·∫°o ƒëi·ªÉm ${name} tr√™n ƒë∆∞·ªùng tr√≤n`);
        pointOnCircleStep = 0;
    }
}
</script>
<script>
function addLatex(line, comment) {
    latexCode.push(line + " % " + comment);
}
</script>

</body>
</html>